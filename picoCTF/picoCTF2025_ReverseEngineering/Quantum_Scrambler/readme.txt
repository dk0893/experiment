Pythonスクリプト（quantum_scrambler.py）をダウンロードできます。サーバに接続して進める問題のようです。

<figure class="figure-image figure-image-fotolife" title="Quantum Scrambler（200 points）">[f:id:daisuke20240310:20250311225739p:plain:alt=Quantum Scrambler（200 points）]<figcaption>Quantum Scrambler（200 points）</figcaption></figure>

Pythonスクリプトは以下です。

まず、フラグを読み出し、1文字ずつ、数値に変換して、16進数文字列（例："0x70"）にして、それをリストにして、hex_flagリストに追加（例：`[['0x70'], ['0x69'], ...]`）します。その hex_flagリストを引数にして、scramble関数を呼び出します。そこでは、hex_flagリストの中身をいろいろ移動してるようです。

```python
import sys

def exit():
  sys.exit(0)

def scramble(L):
  A = L
  i = 2
  while (i < len(A)):
    A[i-2] += A.pop(i-1)
    A[i-1].append(A[:i-2])
    i += 1
    
  return L

def get_flag():
  flag = open('flag.txt', 'r').read()
  flag = flag.strip()
  hex_flag = []
  for c in flag:
    hex_flag.append([str(hex(ord(c)))])

  return hex_flag

def main():
  flag = get_flag()
  cypher = scramble(flag)
  print(cypher)

if __name__ == '__main__':
  main()
```

サーバに接続してみます。すると、大量の cipher が表示されます。あまりに多いので最初の方だけ貼ります。

```sh
$ nc verbal-sleep.picoctf.net 63779
[['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b'], ['0x70', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54']], '0x79'], ['0x74', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b']], '0x68'], ['0x6f', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b'], ['0x70', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54']], '0x79']], '0x6e'], ['0x5f', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b'], ['0x70', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54']], '0x79'], ['0x74', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b']], '0x68']], '0x69'], ['0x73', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b'], ['0x70', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54']], '0x79'], ['0x74', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b']], '0x68'], ['0x6f', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b'], ['0x70', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54']], '0x79']], '0x6e']], '0x5f'], ['0x77', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b'], ['0x70', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54']], '0x79'], ['0x74', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b']], '0x68'], ['0x6f', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b'], ['0x70', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54']], '0x79']], '0x6e'], ['0x5f', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b'], ['0x70', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54']], '0x79'], ['0x74', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b']], '0x68']], '0x69']], '0x65'], ['0x69', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b'], ['0x70', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54']], '0x79'], ['0x74', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b']], '0x68'], ['0x6f', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b'], ['0x70', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54']], '0x79']], '0x6e'], ['0x5f', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b'], ['0x70', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54']], '0x79'], ['0x74', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b']], '0x68']], '0x69'], ['0x73', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b'], ['0x70', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54']], '0x79'], ['0x74', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b']], '0x68'], ['0x6f', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b'], ['0x70', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54']], '0x79']], '0x6e']], '0x5f']], '0x72'], ['0x64', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x69'], ['0x63', [], '0x6f']], '0x7b'], ['0x70', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54']], '0x79'], ['0x74', [['0x70', '0x69'], ['0x63', [], '0x6f'], ['0x43', [['0x70', '0x69']], '0x54'], ['0x46', [['0x70', '0x
```

結局、どうすればいいのでしょうか。この大きな cipher を復号して、フラグを抽出するということだと思います。では、逆算するような Pythonスクリプトを作ってみます。

その前に、ちょっとした Pythonスクリプトを作りました。ただし、お題の cipher が大きいので、そこは省略して貼りました。仮のフラグを用意して、i と len(L) がどのように推移していくのかを見えるようにしました。

```python
import sys
import copy

cipher = [['0x70', '0x69'], ['0x63', [], '0x6f'], ...]

def scramble(L):
  A = L
  i = 2
  print( f"i={i}, len(L)={len(L)}" )
  while (i < len(A)):
    A[i-2] += A.pop(i-1)
    A[i-1].append(A[:i-2])
    i += 1
    print( f"i={i}, len(L)={len(L)}" )
    
  return L

def main():
    
    print( f"len(cipher)={len(cipher)}" )
    
    flag = [['0x70'], ['0x69'], ['0x63'], ['0x6f'], ['0x43'], ['0x54'], ['0x46'], ['0x7b'], ['0x64'], ['0x65'], ['0x61'], ['0x64'], ['0x62'], ['0x65'], ['0x65'], ['0x66'], ['0x7d'], ['0x70'], ['0x69'], ['0x63'], ['0x6f'], ['0x43'], ['0x54'], ['0x46'], ['0x7b'], ['0x64'], ['0x65'], ['0x61'], ['0x64'], ['0x62'], ['0x65'], ['0x65'], ['0x66'], ['0x7d']]
    
    print( f"len(flag)={len(flag)}" )
    scramble( copy.deepcopy(flag) )
    
    flag.pop( 0 )
    print( f"len(flag)={len(flag)}" )
    scramble( copy.deepcopy(flag) )
    
    flag.pop( 0 )
    print( f"len(flag)={len(flag)}" )
    scramble( copy.deepcopy(flag) )
    
    flag.pop( 0 )
    print( f"len(flag)={len(flag)}" )
    scramble( copy.deepcopy(flag) )

if __name__ == '__main__':
  main()
```

実行します。お題の cipher は、要素数が 17 のようです。scramble関数では、L は、要素数が 1つずつ減っていきます。一方、i は 2 から始まって、1つずつ増えていきます。cipher の要素数が 17 になるパターンは 2つあります。2通り試せばいいですね。

```sh
$ python quantum_scrambler_pre.py
len(cipher)=17
len(flag)=34
i=2, len(L)=34
i=3, len(L)=33
i=4, len(L)=32
i=5, len(L)=31
i=6, len(L)=30
i=7, len(L)=29
i=8, len(L)=28
i=9, len(L)=27
i=10, len(L)=26
i=11, len(L)=25
i=12, len(L)=24
i=13, len(L)=23
i=14, len(L)=22
i=15, len(L)=21
i=16, len(L)=20
i=17, len(L)=19
i=18, len(L)=18
len(flag)=33
i=2, len(L)=33
i=3, len(L)=32
i=4, len(L)=31
i=5, len(L)=30
i=6, len(L)=29
i=7, len(L)=28
i=8, len(L)=27
i=9, len(L)=26
i=10, len(L)=25
i=11, len(L)=24
i=12, len(L)=23
i=13, len(L)=22
i=14, len(L)=21
i=15, len(L)=20
i=16, len(L)=19
i=17, len(L)=18
i=18, len(L)=17
len(flag)=32
i=2, len(L)=32
i=3, len(L)=31
i=4, len(L)=30
i=5, len(L)=29
i=6, len(L)=28
i=7, len(L)=27
i=8, len(L)=26
i=9, len(L)=25
i=10, len(L)=24
i=11, len(L)=23
i=12, len(L)=22
i=13, len(L)=21
i=14, len(L)=20
i=15, len(L)=19
i=16, len(L)=18
i=17, len(L)=17
len(flag)=31
i=2, len(L)=31
i=3, len(L)=30
i=4, len(L)=29
i=5, len(L)=28
i=6, len(L)=27
i=7, len(L)=26
i=8, len(L)=25
i=9, len(L)=24
i=10, len(L)=23
i=11, len(L)=22
i=12, len(L)=21
i=13, len(L)=20
i=14, len(L)=19
i=15, len(L)=18
i=16, len(L)=17
i=17, len(L)=16
```

逆に操作する Pythonスクリプトを実装しました。

```python
import sys

cipher = [['0x70', '0x69'], ['0x63', [], '0x6f'], ...]

def main():
    
    global cipher
    
    print( f"len(cipher)={len(cipher)}" ) # whileループを抜けるときは、i と len(A) は同じ値？のはず
    
    # i=18, len(L)=17 → i=17, len(L)=17
    #ii = 17
    ii = 16
    
    while( ii >= 2 ):
        
        # A[16].append(A[:15])：A[:15] を A[16] の末尾に追加 → A[16] の末尾の要素を削除する
        print( f"ii={ii}, len(cipher[ii-1])={len(cipher[ii-1])}" )
        cipher[ii - 1].pop( -1 )
        
        # A[15] += A.pop(16)： → A[15] の末尾の要素を抽出して、A の末尾に追加する
        cipher.insert( ii - 1, [cipher[ii - 2].pop(-1)] )
        
        ii -= 1
        
        print( f"ii={ii}, len(cipher)={len(cipher)}" )
    
    print( cipher )
    
    ss = ""
    for cc in cipher:
        ss += chr( int(cc[0], 16) )
    
    print( ss )

if __name__ == '__main__':
  main()
```

実行します。フラグが表示されました。

```sh
$ python quantum_scrambler_decrypt.py
len(cipher)=17
ii=16, len(cipher[ii-1])=2
ii=15, len(cipher)=18
ii=15, len(cipher[ii-1])=2
ii=14, len(cipher)=19
ii=14, len(cipher[ii-1])=2
ii=13, len(cipher)=20
ii=13, len(cipher[ii-1])=2
ii=12, len(cipher)=21
ii=12, len(cipher[ii-1])=2
ii=11, len(cipher)=22
ii=11, len(cipher[ii-1])=2
ii=10, len(cipher)=23
ii=10, len(cipher[ii-1])=2
ii=9, len(cipher)=24
ii=9, len(cipher[ii-1])=2
ii=8, len(cipher)=25
ii=8, len(cipher[ii-1])=2
ii=7, len(cipher)=26
ii=7, len(cipher[ii-1])=2
ii=6, len(cipher)=27
ii=6, len(cipher[ii-1])=2
ii=5, len(cipher)=28
ii=5, len(cipher[ii-1])=2
ii=4, len(cipher)=29
ii=4, len(cipher[ii-1])=2
ii=3, len(cipher)=30
ii=3, len(cipher[ii-1])=2
ii=2, len(cipher)=31
ii=2, len(cipher[ii-1])=2
ii=1, len(cipher)=32
[['0x70'], ['0x69'], ['0x63'], ['0x6f'], ['0x43'], ['0x54'], ['0x46'], ['0x7b'], ['0x70'], ['0x79'], ['0x74'], ['0x68'], ['0x6f'], ['0x6e'], ['0x5f'], ['0x69'], ['0x73'], ['0x5f'], ['0x77'], ['0x65'], ['0x69'], ['0x72'], ['0x64'], ['0x66'], ['0x39'], ['0x64'], ['0x65'], ['0x34'], ['0x34'], ['0x39'], ['0x61'], ['0x7d']]
picoCTF{python_is_weirdf9de449a}
```
