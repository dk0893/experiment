#### 28.1：プログラムにパッチを当てる

プログラムのバイナリを一部変更して、プログラムの動作を変えることを解説しています。書籍では、IDA を使った方法を解説しています。

IDA は、プログラムのバイナリを変更しても、変更後のバイナリをエクスポートする機能が無いそうですが、変更前と変更後の差異は出力できるそうです。
その差異をファイル出力(program.dif)して、バイナリを変更する Pythonスクリプトが紹介されています。

一方、Ghidra には、変更後のバイナリをエクスポートする機能があるようです。
参考書籍の「マスタリングGhidra ―基礎から学ぶリバースエンジニアリング完全マニュアル」の 22章の「バイナリのパッチ」に解説があります。
これを見ながら、ちょっとやってみます。

まず、main関数の逆アセンブラを示します。
0x400768番地で、authenticate関数が実行されます。
その次の行（test eax,eax）は、AND をとって、結果がゼロかどうかをレジスタに反映します。
その次の行で、ゼロなら、0x40077f番地に飛び、異常処理になり、ゼロじゃなければ正常処理（パスワード一致）になります。

この行を反転させれば、間違ったパスワードを入力すると、パスワードが一致した、という結果に出来ます。
具体的には、0x40076f番地の `je 0x40077f <main+101>` を jnz に変更したいということです。

```asm
pwndbg> disassemble main
Dump of assembler code for function main:
   0x000000000040071a <+0>:     push   rbp
   0x000000000040071b <+1>:     mov    rbp,rsp
   0x000000000040071e <+4>:     sub    rsp,0x40
   0x0000000000400722 <+8>:     mov    DWORD PTR [rbp-0x34],edi
   0x0000000000400725 <+11>:    mov    QWORD PTR [rbp-0x40],rsi
   0x0000000000400729 <+15>:    mov    rax,QWORD PTR fs:0x28
   0x0000000000400732 <+24>:    mov    QWORD PTR [rbp-0x8],rax
   0x0000000000400736 <+28>:    xor    eax,eax
   0x0000000000400738 <+30>:    lea    rdi,[rip+0xf5]        # 0x400834
   0x000000000040073f <+37>:    mov    eax,0x0
   0x0000000000400744 <+42>:    call   0x400550 <printf@plt>
   0x0000000000400749 <+47>:    lea    rax,[rbp-0x30]
   0x000000000040074d <+51>:    mov    rsi,rax
   0x0000000000400750 <+54>:    lea    rdi,[rip+0xee]        # 0x400845
   0x0000000000400757 <+61>:    mov    eax,0x0
   0x000000000040075c <+66>:    call   0x400560 <__isoc99_scanf@plt>
   0x0000000000400761 <+71>:    lea    rax,[rbp-0x30]
   0x0000000000400765 <+75>:    mov    rdi,rax
   0x0000000000400768 <+78>:    call   0x4006ab <authenticate>
   0x000000000040076d <+83>:    test   eax,eax
   0x000000000040076f <+85>:    je     0x40077f <main+101>
   0x0000000000400771 <+87>:    lea    rdi,[rip+0xd2]        # 0x40084a
   0x0000000000400778 <+94>:    call   0x400520 <puts@plt>
   0x000000000040077d <+99>:    jmp    0x40078b <main+113>
   0x000000000040077f <+101>:   lea    rdi,[rip+0xd9]        # 0x40085f
   0x0000000000400786 <+108>:   call   0x400520 <puts@plt>
   0x000000000040078b <+113>:   mov    eax,0x0
   0x0000000000400790 <+118>:   mov    rdx,QWORD PTR [rbp-0x8]
   0x0000000000400794 <+122>:   xor    rdx,QWORD PTR fs:0x28
   0x000000000040079d <+131>:   je     0x4007a4 <main+138>
   0x000000000040079f <+133>:   call   0x400540 <__stack_chk_fail@plt>
   0x00000000004007a4 <+138>:   leave
   0x00000000004007a5 <+139>:   ret
End of assembler dump.
```

一応、0x40084a と 0x40085f のどちらが正常パスなのかが分からないので、文字列を確認しておきます。0x40084a の方が、正常パスでした。

```sh
pwndbg> x/20c 0x40084a
0x40084a:       80 'P'  97 'a'  115 's' 115 's' 119 'w' 111 'o' 114 'r' 100 'd'
0x400852:       32 ' '  105 'i' 115 's' 32 ' '  99 'c'  111 'o' 114 'r' 114 'r'
0x40085a:       101 'e' 99 'c'  116 't' 33 '!'
```

では、Ghidra でパッチを当ててみます。0x40076f番地で右クリックして、Patch Instruction をクリックします。
すると、命令を編集できるので、JE を JNZ に変更します。JNZ に変更すると、命令のバイト列が出るので、長さが変わらないことを確認して実行します。

図：ghidra_patch.png

その後、保存して（File → Save All）、エクスポートします（File → Export Program... で、Format を Original File にする）。
エクスポート結果を確認します。1byteだけが差分になっています（74→75に変化）

図：winmerge_patch.png


```sh
$ hexdump -C program > program.hex

$ hexdump -C program_patch > program_patch.hex

$ diff program.hex program_patch.hex
--- program.hex 2024-12-28 20:23:36.566180939 +0900
+++ program_patch.hex   2024-12-28 20:23:44.252843329 +0900
@@ -116,7 +116,7 @@
 00000730  00 00 48 89 45 f8 31 c0  48 8d 3d f5 00 00 00 b8  |..H.E.1.H.=.....|
 00000740  00 00 00 00 e8 07 fe ff  ff 48 8d 45 d0 48 89 c6  |.........H.E.H..|
 00000750  48 8d 3d ee 00 00 00 b8  00 00 00 00 e8 ff fd ff  |H.=.............|
-00000760  ff 48 8d 45 d0 48 89 c7  e8 3e ff ff ff 85 c0 74  |.H.E.H...>.....t|
+00000760  ff 48 8d 45 d0 48 89 c7  e8 3e ff ff ff 85 c0 75  |.H.E.H...>.....u|
 00000770  0e 48 8d 3d d2 00 00 00  e8 a3 fd ff ff eb 0c 48  |.H.=...........H|
 00000780  8d 3d d9 00 00 00 e8 95  fd ff ff b8 00 00 00 00  |.=..............|
 00000790  48 8b 55 f8 64 48 33 14  25 28 00 00 00 74 05 e8  |H.U.dH3.%(...t..|
```

パッチを当てたバイナリを実行してみます。OKです。

```sh
$ ./program_patch
Enter password: 0123456789
Password is correct!
```

今回の場合は変更後の命令のサイズが、変更前の命令のサイズと同じだったので、簡単にパッチを当てることが出来ました。
もし、変更後の命令のサイズが、変更前の命令のサイズよりも小さい場合は、空いたところに、nop命令を埋めればいいですね。
変更後の命令のサイズが、変更前の命令のサイズよりも大きい場合は難しいです。
このケースについても参考文献の「マスタリングGhidra ―基礎から学ぶリバースエンジニアリング完全マニュアル」に解説があるので、必要になったら理解したいと思います。

